# 🚀 Framix｜画帧秀

![LOGO](schematic/resources/images/illustration/Readme.png)

---

## 🌟 破浪寻速 - 性能测试的新挑战

### ⭐️ 传统
- 随着移动应用的架构和功能变得日益复杂化，传统的性能测试方法，尤其是基于代码埋点的策略，正面临前所未有的挑战。

### ⭐️ 繁琐
- 在当今快速迭代和持续部署的软件开发周期中，基于代码埋点的这种传统方法往往过于繁琐，无法有效适应快速变化的需求。
- 代码埋点不仅消耗大量的开发资源，还可能无法提供足够全面的性能见解，从而影响决策的效率和准确性。

### ⭐️ 关键
- 在这种背景下，如何快速、准确地验证和监测性能优化措施的效果，成为了软件工程领域中的关键问题。

### ⭐️ 限制
- 传统的性能测试方法往往依赖于手动定义的性能指标和预设的测试路径，这限制了测试的全面性和灵活性。
- 此外，由于移动设备和操作系统的多样性，性能测试需要在不同的硬件和软件环境中重复进行，进一步增加了测试的复杂性。

### ⭐️ 迫切
- 因此，现代软件开发迫切需要一种更智能、更高效的性能测试方法，能够适应持续集成和持续部署（CI/CD）的要求，同时提供更深入、更广泛的性能洞察。
- 这种方法应能自动适应各种测试场景，快速捕捉和分析性能瓶颈，从而支持开发团队做出更加数据驱动的决策，以优化应用的整体性能和用户体验。

---

## 💫 时间之刃 - 耗时测试的意义和重要性
- 耗时测试（Timing Test）是软件测试中的一个重要环节，旨在评估软件系统或组件在特定操作或任务中的时间消耗情况。

### ⭐️ 以下是耗时测试的意义和重要性详细阐述:

#### ✨ 性能评估
- **意义**: 通过耗时测试，可以评估系统在执行各种操作时的性能表现，了解哪些操作消耗的时间较长，从而识别性能瓶颈。
- **重要性**: 确保系统在预期的工作负载下能够高效运行，避免因性能问题导致用户体验不佳或系统崩溃。

#### ✨ 响应时间优化
- **意义**: 测试系统的响应时间，特别是对于用户交互频繁的应用程序，这一指标直接影响用户满意度。
- **重要性**: 优化响应时间可以提高用户体验，增加用户对系统的信任和依赖，从而提高用户留存率和满意度。

#### ✨ 资源利用效率
- **意义**: 耗时测试帮助了解系统在不同负载下的资源使用情况，如CPU、内存、网络带宽等，评估资源利用效率。
- **重要性**: 提高资源利用效率，降低运行成本，同时确保系统能够在资源受限的环境中稳定运行。

#### ✨ 可靠性和稳定性
- **意义**: 通过长期地耗时测试，可以评估系统的稳定性和可靠性，识别在长时间运行过程中可能出现的性能退化问题。
- **重要性**: 确保系统在长时间运行下依然保持高效和稳定，避免由于性能退化导致的系统故障或服务中断。

#### ✨ 瓶颈识别和优化
- **意义**: 通过分析耗时测试结果，可以识别系统中的性能瓶颈所在，并针对这些瓶颈进行优化。
- **重要性**: 优化系统性能，提升整体处理能力，确保在高负载或突发流量情况下系统能够稳定运行。

#### ✨ 制定服务等级协议（SLA）
- **意义**: 耗时测试提供了关于系统性能的详细数据，帮助企业制定合理的服务等级协议，确保对客户的服务承诺能够实现。
- **重要性**: 提供可靠的性能指标，增强客户信心，提高服务的可信度和市场竞争力。

#### ✨ 提升用户体验
- **意义**: 测试用户操作的响应时间，确保关键操作在合理时间内完成，从而提升用户体验。
- **重要性**: 优化用户交互流程，减少等待时间，提高用户对应用程序的满意度和使用率。

#### ✨ 实际应用场景
- **Web应用程序**
  - 测试页面加载时间、数据库查询时间、API响应时间等。
  - 优化前端和后端性能，确保用户在浏览器端的操作快速响应。
- **移动应用**
  - 测试启动时间、网络请求时间、界面切换时间等。
  - 提高应用的流畅度和响应速度，增强用户体验。
- **嵌入式系统**
  - 测试传感器数据处理时间、任务调度时间、设备响应时间等。
  - 确保嵌入式设备在实时应用中能够及时响应外部事件。
- **数据库系统**
  - 测试查询执行时间、事务处理时间、索引重建时间等。
  - 优化数据库性能，确保高效的数据存取和处理。
- **网络服务**
  - 测试网络请求延迟、数据传输时间、服务响应时间等。
  - 提高网络服务的响应速度和可靠性，确保稳定的用户访问体验。

### ⭐️ 结论
#### ✨ 耗时测试在软件开发和维护过程中具有重要的意义和作用。
- 通过系统的耗时测试，可以有效识别和优化系统中的性能瓶颈，提升系统的响应速度和资源利用效率，确保系统在各种环境下的稳定性和可靠性。
- 最终，这些优化和改进将直接提升用户体验，增强系统的市场竞争力和客户满意度。因此，耗时测试是软件测试中不可或缺的重要环节。

---

## 🔆 时光探秘 - 全面耗时测试
- 在现代软件开发和运维过程中，性能测试犹如时光探秘，深入挖掘系统各个方面的时间表现，包括启动耗时、页面切换耗时和技能执行耗时，面对着技术的迅猛发展和用户期望的不断提升，这一探索显得尤为重要和富有挑战性。

### ⭐️ APP启动耗时
#### ✨ 定义: 
- APP启动耗时指的是从用户点击应用图标到应用完全加载并显示第一个可交互界面的时间。
#### ✨ 影响因素:
- **冷启动**: 应用在没有任何后台进程的情况下启动，这通常是启动速度最慢的一种情况。
- **热启动**: 应用在后台运行或被部分加载时启动，比冷启动快。

### ⭐️ 页面切换耗时
#### ✨ 定义: 
- 页面切换耗时指的是从用户执行页面切换操作（如点击按钮）到新页面完全加载并可以交互的时间。
#### ✨ 影响因素:
- **UI复杂度**: 页面元素数量和复杂度，复杂页面加载时间较长。
- **数据加载**: 新页面需要从本地或远程服务器加载数据，数据量和网络速度会影响切换速度。
- **动画和过渡效果**: 页面切换动画的执行时间。

### ⭐️ 技能执行耗时
#### ✨ 定义: 
- 技能执行耗时指的是用户触发某项功能（如搜索、计算、数据处理）到功能完成并返回结果的时间。
#### ✨ 影响因素:
- **算法效率**: 功能实现的算法复杂度，影响执行时间。
- **硬件性能**: 设备的处理能力，如CPU和内存。
- **数据处理量**: 需要处理的数据量越大，执行速度越慢。
- **网络延迟**: 如果技能执行需要与服务器通信，网络速度和延迟会影响执行时间。

---

## 🏆 突破边界 - 项目简介

### ⭐️ 前沿技术
- **Framix** 不仅是工具，更是革新，它是为追求极致性能的移动应用开发者量身定做的一款艺术品。
- **Framix** 结合了前沿技术，旨在捕捉移动应用的每一次心跳，每一个呼吸。
- **Framix** 不只是测量启动速度，我们深入到页面加载的微妙细节，确保每个动作流畅自然，每个响应迅速准确。 
- **Framix** 在这个速度定义一切的时代，将成为您提升应用性能的超级加速器。

### ⭐️ 高度集成
- **Framix** 的核心在于它的技术整合能力。通过结合计算机视觉和人工智能，**Framix** 能够解析复杂的视觉场景，自动检测和分析用户交互和应用响应。这种能力超越了传统性能测试工具的局限，为性能分析提供了前所未有的深度和广度。

### ⭐️ 智能分析
- **Framix** 让性能测试转变为一种智能化、自动化的过程。
- **Framix** 能够精确地识别出视频中的每一个关键帧，并利用机器学习模型分析这些帧之间的关系，从而精确地刻画出应用的性能特征。这种方法不仅大幅提高了测试的效率，而且能够揭示出传统方法难以发现的性能问题。

### ⭐️ 极致体验
- **Framix** 不只是关注技术性能参数，更是深入分析整体用户体验。它通过模拟和分析真实用户操作，能够提供更加直观的性能反馈，确保开发团队能够从用户的角度理解和优化应用。
- **Framix** 的出现，不仅是性能测试领域的一次技术飞跃，更是为软件开发和质量保证领域开辟了新的道路。在这个快节奏、高标准的数字化时代，**Framix** 作为一个创新的工具，为提高工作效率、优化用户体验和推动技术创新提供了强大地支持。

---

## 🎖️ 性能革命 - 埋点与视觉分析的融合

### ⭐️ 传统埋点技术
#### ✨ 在软件工程的性能测试领域，传统的埋点技术以其精确性而著称。这种方法涉及在应用程序代码的关键点插入代码段，以监测和记录性能相关的数据。
#### ✨ 然而，尽管埋点方法在精度上有优势，它在实际应用中存在一系列挑战:
1. **有限地覆盖范围**: 埋点只能收集到预先定义好的性能指标，无法捕捉到所有潜在的性能问题区域。
2. **代码侵入性**: 埋点需要修改应用程序的代码，这可能会影响代码的清晰度和维护性。
3. **运行时开销**: 每个埋点都会带来一定的性能开销，尤其是在大量数据收集和记录的情况下。
4. **动态环境的适应性不足**: 埋点通常无法适应动态变化的运行环境，如用户行为的多样性和复杂性。

### ⭐️ 视觉分析技术
#### ✨ 为了克服这些限制，Framix 引入了自动化视觉分析技术，与传统的埋点方法形成了高效融合。
#### ✨ 自动化视觉分析利用先进的图像处理和模式识别技术，从视觉角度监测和分析应用程序的性能表现。这种方法的优势包括:
1. **全面性能分析**: 视觉分析能够全面监控应用程序的性能表现，覆盖传统埋点无法达到的区域。
2. **非侵入式设计**: 无需修改应用程序代码，从而保持了原有代码的完整性和可维护性。
3. **用户体验中心**: 通过模拟和分析用户实际看到的界面，**Framix** 提供了更符合用户体验的性能评估。
4. **智能数据处理**: 结合机器学习和数据分析算法，**Framix** 能自动识别关键性能瓶颈，提供深入的性能诊断。
5. **适应性强**: 能够适应动态变化的用户交互模式和应用场景，有效地捕捉在实际使用中可能出现的各种性能问题。

```
「画面捕捉器」───▶ 捕捉用户视角下的实时画面
     ↓
「光学调整室」───▶ 缩放、裁剪、灰度处理 —— 清洗图像
     ↓
「识别感应台」───▶ 模式识别：按钮、文字、图标等元素激活
     ↓
「焦点探测仓」───▶ 聚焦关键区域：手指点击 / 光标移动
     ↓
「行为拆解台」───▶ 解析操作节奏：停顿、滑动、快速跳转
     ↓
「时间融合炉」───▶ 重建交互轨迹，恢复真实使用过程
     ↓
「洞察投影墙」───▶ 输出智能报告：性能热点 / 异常识别 / UX节奏
```

---

## 🎯 使命宣言
- **Framix** 致力于最简洁、高效的性能优化工具。为移动应用开发者提供一个无与伦比的优化利器。
- **Framix** 专注于提升应用的启动效率和页面响应速度，使性能优化不再是难题。

---

## 🔧 工程艺术
- **Framix** 构建于一系列高效的编程框架与技术之上，涵盖了从数据解析、视频处理、可视化渲染到硬件控制的完整技术链。
- 采用异步协程调度、模块化架构设计、跨平台命令桥接、富文本终端交互等工程策略，使其在性能与可扩展性上达到高度平衡。
- 无论是数据科学家、开发者还是视频分析人员，**Framix** 都能作为底层支撑，提供坚实而优雅的技术基础。

### ⭐️ 技术架构
```
用户接口层
────────────
CLI / 脚本
  ↓
ArgParser（命令参数解析）
  ↓

调度控制层
────────────
Task Orchestrator（主任务调度器）
  ↓
Multiprocess Scheduler（多进程调度器）
  ├─ 为每个设备/任务启动独立进程
  ├─ 控制子任务回收与异常隔离
  ↓
Task Orchestrator（异步任务调度器）
  ├─ 控制命令分发
  ├─ 管理协程与超时
  ↓

功能执行层（核心模块）
────────────────────
[VideoCutter] ──▶ Video interval division
     │                   │
     ▼                   ▼
[FrameSaveHook]    [VideoObject] ←  ───────────────────────────────────────┐
     │                   │                                                 │
     ▼                   ▼                                                 │
[Classifier] ────────▶ reasoning fragment ──────────────────  →  SingleClassifierResult
     │                                                                     │
     ▼                                                                     │
[Analyzer] ─────────▶ Analyze statistical curves                           │
     │                                                                     │
     ▼                                                                     │
[Report] ───────────▶ Structured report rendering                          │
     │                                                                     │
     ▼                                                                     │
[Device / Runner] → Multi-device screen recording / control playback ──────┘

输出呈现层
────────────
├─ HTML 报告 (带图表)
├─ 分析图片 / 视频帧
└─ JSON 格式数据包
```

---

## 🌐 平台兼容
- **Framix** 自底层设计起就以“跨平台无感知”为核心，支持 Windows、macOS、以及部分类 Unix 系统，为开发者与非技术用户提供一致的交互体验。
- 无需额外适配，**Framix** 自动检测系统环境，选择最优的工具链与系统命令，实现对系统级差异的“软隐藏”与“逻辑转译”。
- 核心组件采用平台抽象层封装，包括路径规则、文件系统调用、终端输出样式与编码规范，确保在不同操作系统间保持行为一致性。
- 对于需要依赖第三方程序的功能，**Framix** 提供了按平台自动部署和替换机制，降低安装门槛并提升稳定性。
- 在多平台测试覆盖方面，**Framix** 采用 CI 自动化构建、集成 GitHub Actions/macOS Runners/Windows Shell，确保每一版更新均通过平台级回归验证。

### ⭐️ 应用场景
- **多系统部署**: 你可以在 macOS 预处理数据，再在 Windows 上导出报告，**Framix** 会保证一致输出格式。
- **跨团队协作**: 不同系统间的开发人员共享 **Framix** 项目不再面临兼容问题，提升团队协作效率。
- **云端适配**: **Framix** 能在本地、WSL、甚至云端容器中无缝运行，适合视频处理 SaaS 工具或离线模型预处理部署。

### ⭐️ 系统检测流程（System Detection Flow）
```
Framix CLI Session
  ↓
获取操作系统平台标识
  ↓
判断平台类型
  ├─ Windows
  │    ↓
  │  加载 Windows 分支配置
  ↓
  └─ macOS / Linux
       ↓
     加载 Unix 分支配置
  ↓
加载平台专属路径规则
  ↓
进入主程序流程
```

### ⭐️ 依赖分发路径（Dependency Distribution Strategy）
```
检查平台依赖状态
  ↓
是否存在系统工具
  ├─ 是 → 使用系统工具
  ↓
  └─ 否
     ↓
   是否存在内置压缩包
     ├─ 是 → 解压并安装到临时目录
     ↓
     └─ 否 → 下载官方二进制并安装
        ↓
将工具路径注入 Framix 执行上下文
  ↓
开始正常任务处理
```

---

## 📦 内置工具

### ⭐️ Framix 内置了以下工具的不同版本，确保无论在哪个平台，Framix 都能完美运行:
- **[Android SDK Platform-Tools](https://developer.android.com/tools/releases/platform-tools)**: 为安卓设备提供广泛的调试和测试功能。
- **[FFmpeg](https://ffmpeg.org/)**: 强大的多媒体处理能力，助您录制、转换和分析视频。
- **[FFprobe](https://ffmpeg.org/)**: 强大的多媒体元信息提取工具，能以极高的灵活性和精度解析音视频文件的所有结构与属性细节。

### ⭐️ 自动检测
- **Framix** 拥有完善的系统识别机制，能够自动侦测用户操作系统环境（如 Windows、macOS），并基于架构智能匹配对应的运行组件。
- 用户无需手动选择工具链或担心兼容性问题，从配置到执行，一切过程均由系统智能完成，助您实现即装即用。

```
                Framix Platform Compatibility
┌────────────────────────────────────────────────────────────┐
│ User Execution                                             │
├────────────┬────────────┬────────────┬─────────────────────┤
│ Windows    │  macOS     │  Linux/WSL │  Others (Future)    │
├────────────┴────────────┴────────────┴─────────────────────┤
│ Platform Abstraction Layer                                 │
│   ↳ OS Detection     ↳ Path Resolver     ↳ Charset Mapping │
│   ↳ FFmpeg Bindings  ↳ Terminal Control  ↳ File Proxy      │
├────────────────────────────────────────────────────────────┤
│ Platform-Specific Dependency Loader                        │
│   ↳ ffmpeg.exe / ffmpeg (mac) / apt install fallback       │
│   ↳ adb.exe / adb (brew) / static binaries fallback        │
├────────────────────────────────────────────────────────────┤
│ Unified Task Dispatcher                                    │
│           ↳ Async Execution  ↳ CLI Flow Management         │
└────────────────────────────────────────────────────────────┘
```

### ⭐️ 优化安装
- **Framix** 采用轻量级部署架构，通过内置压缩与按需提取机制，确保安装包体积尽可能小。
- 所有依赖组件将在真正需要时下载并部署，极大减轻磁盘占用，并提升首次启动的效率和体验。

```
       Framix Installer
              |
   -----------------------
   |          |          |
   |        Keras        |     
   U2         |         TF  
   |    Platform tools   |    
Notepad       |          |
   |      FF series    Model
   |          |          |
   |         CLI    [on demand]
  PIL         |          |
   |      Automatic      |
   |          |          |
   -----------------------
              |
       Deployment done   
```

### ⭐️ 定期更新
- **Framix** 维护内核与工具链的常态化迭代机制，确保各项能力始终处于最新状态，涵盖兼容性、性能优化、安全补丁等多方面。
- 用户可选择自动或手动获取更新，无需担忧落后于主流版本，每一次运行都将是稳定且安全的体验。

---

## 🧭 安装指南

### ⭐️ Framix 提供简洁明了的安装包，让您能够轻松开始您的性能测试之旅。
- **1. 下载**: 访问我们的 [发布页面](https://github.com/PlaxtonFlarion/NexaFlow/releases) 下载最新版的 **Framix** 安装包。
- **2. 安装**: 运行下载的安装包，并按照提示完成安装过程，安装完成后设置系统环境变量。
- **3. 启动**: 安装完成后，通过命令行启动 **Framix** 开始体验高效的性能测试。
- **4. 体验**: 如果您使用的是 **Windows** 操作系统，为了增加体验感，强烈建议您使用 [Windows Terminal](https://apps.microsoft.com/detail/9N0DX20HK701) 等现代终端。
- **5. 就绪**: 在 **Framix** 启动前，确保所有系统正常。

---

## 📖 快速上手

### ⭐️ Framix 提供了一系列命令行参数来控制不同的功能和行为。
- **Framix** 的使用可能需要一定的命令行知识。如果您不熟悉命令行操作，建议先了解基础的命令行使用方法。
```
命令输入 ───► 参数解析 ───► 调度器选择 ───► 功能模块执行 ───► 输出结果
               │             │               │
               │             │               ├──► 视频处理（剪辑 / 解帧 / 模糊）
               │             │               ├──► 图像分析（分类 / 标注 / 对比）
               │             │               ├──► 模型调用（Keras / ONNX）
               │             │               └──► 多设备任务调度
               │             └──► 路由不同模式
               │                      ├── speed 极速拆帧，不注入时间戳
               │                      ├── basic 注入时间戳，结构化处理
               │                      └── keras 深度模型预测 + 关键帧识别
               │
               └──► 预处理 Hook（裁剪 / 缩放 / 灰度化等）
```

---

## 🔰 核心操控

### ⚜️ 视频解析探索 (`--video`)
#### 📔 功能描述:
- 启用对单个或批量视频文件的多维度内容解析，涵盖结构化帧处理、视觉特征提取与音频质量扫描等功能模块。
- 支持自动识别视频分段、分析关键事件并提取元信息，为后续的机器学习、内容审核或质量控制提供基础数据支持。
- 该命令适用于构建高性能视频分析流程，助力智能化内容识别与全流程可视化评估。
#### 📔 参数说明: 
- 可接受一个或多个视频文件路径作为输入，允许一次性处理多个文件，以便进行批量分析。
- 如果文件路径或文件夹路径中**包含空格**，请使用英文双引号 `"` 或单引号 `'` 将路径整体包裹，以避免命令行解析错误。
- ✅ 正确示例
```
framix --video "C:/Users/Alice/Videos/My Sample.mp4"
```
- ❌ 错误示例（未加引号）
```
framix --video C:/Users/Alice/Videos/My Sample.mp4
# ↑ 会被解析为多个参数，导致路径无效或异常退出
```
- 推荐路径中避免使用空格或中文字符。
- 若使用自动脚本或批处理生成命令，请确保路径变量加上引号。
#### 📔 操作细节:
- **视频质量评估**: 自动检测视频中的像素错误、压缩损失和颜色分辨率。
- **内容识别**: 使用机器学习模型识别视频中的对象、场景和活动。
- **元数据分析**: 提取并分析视频文件的元数据，如编码格式、持续时间、帧率等。
#### 📔 应用场景:
- **内容创作者**: 在发布前检查视频质量，确保内容达到发布标准。
- **教育专家**: 分析教学视频，评估教材的视听质量和内容的适宜性。
- **安全监控**: 评估和分析监控视频的清晰度和识别可能的异常事件。
#### 📔 实际应用: 
```
framix --video <视频文件路径> --video <视频文件路径> --video <视频文件路径>
```

### ⚜️ 影像堆叠导航 (`--stack`)
#### 📔 功能描述:
- 用于组织和分析由多个视频构成的序列或集合，支持统一加载、同步处理以及帧级别的比对和汇总分析。
- 适用于批量视频管理与结构化解构场景，尤其针对多源拍摄、教学课程章节、系列剧集等提供稳定高效的处理方案。
- 该功能旨在提升内容一致性检验、格式统一性评估和跨片段逻辑链路的构建效率。
#### 📔 参数说明: 
- 可接受一组视频文件所在的文件夹路径，支持多次传递不同的文件夹进行集中处理。
- 每个路径应指向一个结构化的视频任务目录。
#### 📔 操作细节:
- **格式统一性检查**: 确认系列中所有视频的格式和编码统一，以保证无缝播放。
- **质量评估**：对每个视频进行质量检查，确保整个系列的一致性和高标准。
- **内容连贯性分析**: 分析视频内容之间的连贯性和逻辑流程，特别是对系列教育内容和剧集。
#### 📔 应用场景:
- **电视剧后期制作**: 在剧集发布前确保所有分集之间的视频质量和内容连贯。
- **教育平台**：确保教育视频系列的每个部分都符合教学标准和质量要求。
- **监控系统分析**: 分析来自不同摄像头的录像，以评估监控系统的效能和覆盖范围。
#### 📔 实际应用:  
```
framix --stack <文件夹路径> --stack <文件夹路径> --stack <文件夹路径>
```
#### 📔 目录结构:
```
FX_.../
└── Framix_Collection/
    └── group/
        └── group1/
            └── serial/
                ├── video/      ← 原始视频文件（.mp4, .avi 等）
                ├── extra/      ← 补充数据（如元信息、标注、日志）
                └── frame/      ← 视频帧图像（.jpg/.png），按序导出
```
#### 📔 各层说明
| 文件夹                  | 描述                                    |
|----------------------|---------------------------------------|
| `FX_.../`            | 视频文件夹根目录                              |
| `Framix_Collection/` | 采集任务集总目录                              |
| `group/`             | 分组任务，例如不同批次或视频组                       |
| `group1/`            | 具体分组，可为 `group1`, `group2`, `testA` 等 |
| `serial/`            | 单个设备采集记录，每次运行或采样的分目录                  |
| `video/`             | 原始视频输入文件夹，供后续解码与分析使用                  |
| `extra/`             | 补充数据，支持标注信息、分析日志、辅助模型输入等              |
| `frame/`             | 拆帧结果目录，保存按序命名的图像帧                     |

### ⚜️ 模型训练大师 (`--train`)
#### 📔 功能描述: 
- 设计用于对视频数据进行深入分析和处理，准备数据以符合机器学习模型的训练需求。
- 这包括特征提取、数据归一化和训练测试集的划分等关键步骤，确保输入数据能够有效地支持后续的训练过程。
#### 📔 参数说明: 
- 接受一个或多个视频文件路径作为输入，支持批量处理，以便同时准备多个数据集。
- 手动挑选、合并、复制到 `Model_.../` 并确保符合编号规范。
#### 📔 操作细节:
- **特征提取**: 从视频中自动提取关键视觉和音频特征，使用如深度学习算法预训练的模型等先进技术。
- **数据归一化**: 标准化数据以提高模型训练的稳定性和效率。
- **划分数据集**：自动分割数据为训练集、验证集和测试集，以支持模型评估和防止过拟合。
#### 📔 应用场景:
- **人工智能研究**: 为复杂的AI研究项目准备和预处理数据。
- **商业分析应用**: 在零售和监控视频分析中使用，以优化客户行为识别和安全监控系统。
- **教育和训练**: 在在线教育平台中分析教学视频，提取教学内容特征。
#### 📔 实际应用: 
```
framix --train <视频文件路径> --train <视频文件路径> --train <视频文件路径>
```
#### 📔 目录结构:
```
FX_.../
└── Framix_Collection/
    └── Model_.../             ← 训练样本主目录
        ├── 0/                 ← 初步聚类结果
        ├── 1/                 ← 类别 1 的样本集
        ├── 2/                 ← 类别 2 ...
        └── 24/                ← 可达 20+ 类
```
#### 📔 文件说明
| 目录名称            | 说明                      |
|-----------------|-------------------------|
| `Model_.../`    | 模型训练的主目录，按类别划分子文件夹      |
| `0/`, `1/`, ... | 每个子目录表示一个类别，目录名为标签值（整数） |
| 子目录内文件          | `.jpg`, `.png`（已拆帧图）    |
#### ⚠️ 手动归类（用于 `--build`）
1. **归类后目录总数不得超过 6 个**（即标签编号范围：`0~5`）。
2. **第一个目录必须为 `0/`**。
3. **所有目录编号必须是连续整数**，不可跳号（如 `0, 2, 3` 是不合法的）。
4. **目录命名必须是纯数字**，系统将其作为标签编号使用。
#### 📔 合法示例
```
Model_.../
├── 0/       ← 必须存在
├── 1/
├── 2/
```
#### ❌ 非法示例

```
Model_.../
├── 1/       ← 缺少 0
├── 3/       ← 跳号
├── 7/       ← 超出范围
```

### ⚜️ 模型编译大师 (`--build`)
#### 📔 功能描述: 
- 提供从准备好的数据集到机器学习模型文件的转换服务。
- 支持定义模型结构、初始化模型参数并进行编译优化，确保生成的模型既能满足性能要求又具备生产级的可用性。
#### 📔 参数说明: 
- 接受一个或多个已预处理的数据集路径，支持批量编译，以便高效管理大规模机器学习项目。
- 一个指向 `Model_.../` 文件夹的路径，作为模型构建的输入源。
- 每个 `Model_.../` 文件夹中应包含按类别划分的子目录，系统将基于该结构自动执行模型结构创建、数据预处理和编译优化流程。
#### 📔 操作细节:
- **模型定义**: 设定模型的架构，包括层数、激活函数、输出维度等。
- **参数初始化**: 根据指定的初始化策略设置模型的权重和偏差。
- **编译优化**: 应用不同的编译技术，如图优化、算子融合等，以提升模型的执行效率和降低资源消耗。
- **跨平台兼容性**: 确保模型文件在不同的运行环境（如CPU、GPU、TPU）中都能得到良好支持。
#### 📔 应用场景:
- **深度学习产品开发**: 开发高性能的视觉识别和自然语言处理产品。
- **科研**: 在学术研究中，快速从理论到实验阶段的过渡。
- **工业自动化**: 在制造业中，用于产品质量检测和自动化控制系统。
#### 📔 实际应用: 
```
framix --build <文件夹路径> --build <文件夹路径> --build <文件夹路径>
```
#### 📔 目录结构
```
Model_.../     ← 训练样本主目录
├── 0/         ← 类别 0 的样本集
├── 1/         ← 类别 1 的样本集
├── 2/         ← 类别 2 的样本集
├── 3/         ← 类别 3 的样本集
├── 4/         ← 类别 4 的样本集
├── 5/         ← 最多支持到 5（共 6 类）
```
#### 📔 文件说明
- 图片（`.jpg`, `.png`）。
- 按文件夹名（如 `0`, `1`, `2`）作为标签编号。
- 建议每个类别至少包含数十个样本以保障模型训练质量。
#### ⚠️ 限制说明
- 系统最多识别 **6 个子目录**，标签编号为 `0` ~ `5`。
- 若目录中存在超过 6 个子文件夹，将忽略多余部分或触发异常。
- 建议提前规范整理模型输入目录结构。

### ⚜️ 循环节拍器 (`--flick`)
#### 📔 功能描述: 
- 在设定的时间周期内自动进行多轮屏幕录制，并对捕获的视频帧进行持续性分析。
- 支持集成多种智能分析模型，包括但不限于动作识别、内容筛查和情绪解析，适用于长时间监控、行为检测和交互行为建模等复杂场景。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 激活循环节拍器，周期性地进行录制和分析。
- **关闭**: 禁用循环节拍器，停止录制和分析活动。
#### 📔 操作细节:
- **循环录制**: 自动根据预设的时间间隔启动和结束录制，无需手动干预，保证数据的连续性和完整性。
- **多模式分析**: 集成了多种分析算法，如动作识别、情感分析、内容安全检测等，适应不同的分析需求。分析过程中实时生成报告，包括关键帧标记、事件标注和建议，支持快速决策和响应。
#### 📔 应用场景: 
- **用户行为研究**: 在电商平台、游戏测试或社交媒体分析中，通过录制用户操作过程，分析用户行为模式和用户界面的互动效果。
- **游戏测试**: 在游戏开发过程中，监控和分析玩家的游戏体验，识别游戏中可能的问题区域或优化点。
- **软件操作教学**: 制作教程视频时，自动记录操作过程并提取关键步骤，辅助教学内容的编排和优化。。
#### 📔 实际应用: 
```
framix --flick
```

### ⚜️ 脚本驱动者 (`--carry`)
#### 📔 功能描述: 
- 加载并执行指定的单个自动化脚本文件，支持多次传递以覆盖多任务执行场景。
- 每个脚本可通过`key`分隔形式传参，适用于精细化控制单元测试或特定环境配置下的执行逻辑。
#### 📔 参数说明:
- 有效的脚本文件路径和脚本中存在的字段名称，支持多次传递。
#### 📔 操作细节:
- **脚本执行**: 加载并执行指定的脚本文件，支持各种脚本语言，如Python、Bash等。
- **多次传递**: 允许用户在一个命令调用中多次指定和执行不同的脚本文件，用于复杂的测试或任务自动化。
#### 📔 应用场景: 
- 适用于自动化测试、批量数据处理、系统管理等，提供灵活的脚本运行选项。
#### 📔 实际应用: 
```
framix --carry script.json;ID-X
```

### ⚜️ 全域执行者 (`--fully`)
#### 📔 功能描述: 
- 加载一个包含多个自动化脚本的脚本集合并依序执行所有任务，支持并发或序列化控制策略。
- 常用于批量任务执行、回归测试与全流程验证，适合需要高度可扩展与可配置执行机制的系统部署场景。
#### 📔 参数说明:
- 有效的脚本文件路径，支持多次传递。
#### 📔 操作细节:
- **批量执行**: 同时加载并执行一个文件集合中的所有脚本，实现高效的批处理。
- **多次传递**: 允许用户在一个命令调用中对多个脚本集合进行重复执行，适合于大规模自动化测试和任务执行。
#### 📔 应用场景: 
- 适用于需要在多个环境或条件下统一执行多个任务的情况，如软件部署、大规模系统测试等。
#### 📔 实际应用: 
```
framix --fully script.json
```
#### 📔 常规配置:
```json
{
    "command": [
        {
            "ID-X": {
                "parser": {"FST": {"frate": 60}, "ALS": {"boost": true}},
                "header": ["script"],
                "change": [],
                "looper": 1,
                "prefix": [
                    {"cmds": ["key_event"], "vals": [[3]]}, 
                    {"cmds": ["sleep"], "vals": [[1]]}
                ],
                "action": [
                    {"cmds": ["automator"], "vals": [[{"text": "text"}, "click"]]}, 
                    {"cmds": ["sleep"], "vals": [[3]]}
                ],
                "suffix": [
                    {"cmds": ["force_stop"], "vals": [["package_name"]]}, 
                    {"cmds": ["sleep"], "vals": [[1]]}
                ]
            }
        }
    ]
}
```
#### 📔 并发配置:
```json
{
    "command": [
        {
            "ID-X": {
                "parser": {"FST": {"frate": 60}, "ALS": {"boost": true}},
                "header": ["script"],
                "change": [],
                "looper": 1,
                "prefix": [
                    {"cmds": ["key_event", "sleep"], "vals": [[3], [1]]}
                ],
                "action": [
                    {"cmds": ["automator"], "vals": [[{"text": "text"}, "click"]]}, 
                    {"cmds": ["sleep"], "vals": [[3]]}
                ],
                "suffix": [
                    {"cmds": ["force_stop", "sleep"], "vals": [["package_name"], [1]]} 
                ]
            }
        }
    ]
}
```

### ⚜️ 线迹创造者 (`--paint`)
#### 📔 功能描述: 
- 在所有设备捕获的屏幕截图上自动绘制横向和竖向的线条。
- 这一过程可以帮助忽略或专注于图像的特定区域，提高分析的精确度和效率。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 激活线条绘制功能，系统将自动在截图上绘制预设的线条。
- **关闭**: 维持截图的原始状态，不进行任何额外的线条绘制。

```
+--------------------------+
| [ Original Image RGB ]   |
+--------------------------+
             │
             ▼
+--------------------------+
| Image  width × height    |
| Create ImageDraw.Draw    |
+--------------------------+
             │
             ▼
+-------------------------------------------------+
| Vertical line                                   |
| → Position is the image width 20% 40% 60% 80%   |
+-------------------------------------------------+
             │
             ▼
+---------------------------------------------------------+
| Horizontal line                                         |
| → Draw a horizontal line every 5% of the image height   |
+---------------------------------------------------------+
             │
             ▼
+--------------------------+
| Save image               |
+--------------------------+
```

```
 ↑   ↑   ↑   ↑    ← 水平线标签（每5%）
 │   │   │   │
 │   │   │   │
 │   │   │   │
20% 40% 60% 80%   ← 垂直线坐标位置（% of width）

说明
- 垂直线辅助分割区域宽度，对 UI 布局 / 元素识别有辅助作用。
- 水平线精细网格化图像高度，有助于区域关注、训练标定。
- 线条与文字均可进一步拓展配置，如颜色、字体、线型等。
```

#### 📔 操作细节:
- **线条配置**: 用户可以定义线条的颜色、宽度和位置，以适应不同的视觉分析需求。
- **自动化处理**: 一旦激活，系统将对所有新的或指定的屏幕截图自动应用这一设置，确保一致性和准确性。
- **图像预处理**: 在进行更深入的图像分析或机器学习训练前，可以使用此功能预处理图像，突出或隔离关键区域。
#### 📔 应用场景: 
- **用户界面设计评估**: 设计师可以利用此功能高效地评估和调整应用界面的布局。
- **数据可视化**: 在处理包含大量图表的截图时，可以通过绘制线条来标注和区分不同的数据区域。
- **机器学习数据准备**: 在准备机器学习训练集时，可以通过指定区域的线条来自动标注图像，帮助算法更好地识别和学习特定特征。
#### 📔 实际应用: 
```
framix --paint
```

### ⚜️ 时空纽带分析系统 (`--union`)
#### 📔 功能描述: 
- 对无时间戳的视频帧数据进行空间逻辑聚合，构建统一的分析视图以提升帧级结构的一致性。
- 适用于来源不明或无序采样的帧数据整合，有助于支持后续的聚类、标注与建模等流程。
#### 📔 参数说明: 
- 有效的已经分析完成的文件夹，可多次传递。
#### 📔 操作细节: 
- 系统将自动识别和汇总所有提供的文件夹中的视频帧报告，无需时间戳对齐，便于处理来自异步源的数据。
#### 📔 应用场景:
- **研究分析**: 在进行科研或数据分析时，可以整合来自不同实验或时间段的视频数据，以便进行横向或纵向的数据比较。
- **多源视频处理**: 在安全监控或多摄像头系统中，整合来自不同摄像头的视频帧报告，即使这些摄像头未同步。
- **事件重建**: 在事故或事件重建中，通过整合来自不同角度的视频帧，提供全面的视角和信息。
#### 📔 实际应用: 
```
framix --union <文件夹路径> --union <文件夹路径> --union <文件夹路径>
```

### ⚜️ 时序融合分析系统 (`--merge`)
#### 📔 功能描述: 
- 对附带时间戳的视频帧报告进行时序对齐与结构整合，实现多源数据的时间轴同步与动态重构。
- 适用于需要高精度时间分析的场景，如事件回溯、交叉验证或多模态融合。
#### 📔 参数说明: 
- 有效的已经分析完成的文件夹，可多次传递。
#### 📔 操作细节: 
- 系统将根据时间戳对视频帧进行排序和同步，确保时间的连续性和准确性。
#### 📔 应用场景:
- **法律取证**: 在需要时间证据的法律案件中，确保视频证据的时间一致性和可追踪性。
- **媒体制作**: 在制作纪录片或新闻报道时，整合具有确切时间标记的视频片段，确保事件的时间线准确无误。
- **行为分析**: 在进行行为学研究时，通过精确的时间戳对视频进行分析，了解事件发生的精确时序。
#### 📔 实际应用: 
```
framix --merge <文件夹路径> --merge <文件夹路径> --merge <文件夹路径>
```

---

### ⚜️ 对话协调器 (`--talks`)
#### 📔 功能描述: 
- 读取配置源，动态注入或修改参数后重新回写并解析，形成统一配置视图。
- 适合复杂自动化场景中对任务参数进行多轮协商、联动触发和格式化展示，构建灵活的配置执行闭环。
- 可用于快速调试、远程参数对话、配置集成与策略推演等复杂流程。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`，启用后触发配置对话预览流程。
#### 📔 操作细节:
加载路径 `Structure/Framix_Mix/deploy.json`
1. 导出当前配置内容到中间 JSON 文件。
2. 使用系统默认编辑器打开该文件，供用户修改。
3. 用户关闭编辑器后，配置文件自动重新加载。
4. 格式化输出当前配置内容，便于确认修改结果。
#### 📔 应用场景: 
- 本地配置的快速调试与修改确认。
- 多人协作中远程修改参数并共享视图。
- 自动化任务链中前置参数校对流程。
- 运行前预览与干预敏感参数值。
#### 📔 实际应用: 
```
framix --talks
```
#### 📔 分析配置:
- Structure
  - Framix_Mix
    - deploy.json

```json
{
    "FST":{
        "shape":null,
        "scale":null,
        "start":null,
        "close":null,
        "limit":null,
        "gauss":null,
        "grind":null,
        "frate":60
    },
    "ALS":{
        "boost":false,
        "color":false,
        "begin":[0, 1],
        "final":[-1, -1],
        "thres":0.98,
        "shift":3,
        "slide":1,
        "block":3,
        "scope":1,
        "grade":2,
        "crops":[
            {"x":0, "y":0, "x_size":0, "y_size":0}
        ],
        "omits":[
            {"x":0, "y":0, "x_size":0, "y_size":0}
        ]
    }
}
```

### ⚜️ 回环注入器 (`--rings`)
#### 📔 功能描述: 
- 预设运行所需的关键配置参数，包括报告路径、模型路径、彩色与灰度模型名称等。
- 用于在主流程执行前注入标准化运行环境，确保任务执行上下文一致且可复现。
- 与其他功能配合使用时，可作为基础参数注入器，完成运行逻辑与资源配置的解耦。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`，启用后将读取并注入全局运行环境配置。
#### 📔 操作细节:
加载路径 `Structure/Framix_Mix/option.json`
- 报告目录（total_place）
- 模型目录（model_place）
- 模型选择（color_model, faint_model）
- 注入结果将在后续模块中统一使用。
#### 📔 应用场景: 
- 在多个任务流程中共用统一模型路径和输出路径。
- 做任务批处理时统一前置环境。
- 远程执行时避免硬编码路径，支持多机同步部署。
- 灵活切换模型组以验证对比效果。
#### 📔 实际应用: 
```
framix --rings
```
#### 📔 全局配置:
- Structure
  - Framix_Mix
    - option.json

```json
{
    "total_place": "报告文件夹路径",
    "model_place": "模型文件夹路径",
    "faint_model": "灰度模型名称",
    "color_model": "彩色模型名称"
}
```

## 🔰 辅助利器

### ⚜️ 光速穿梭 (`--speed`)
#### 📔 功能描述:
- 快速执行视频帧的结构化解构，绕过时间戳计算步骤，直接生成帧级报告，大幅提升处理效率。
- 适用于对时序精度要求不高但对性能敏感的场景，如预处理任务、粗筛分析或快速回溯。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 通过调用优化算法以最大化帧处理速度，从而加快拆帧过程。
- **关闭**: 维持标准拆帧处理，适合常规视频处理需求。

```
+----------------------------------------------------------------------+
|                      FAST FRAME DECOMPOSITION MODE                   |
+----------------------------------------------------------------------+

┌─────────────────┐
│   Video Input   │
└────────┬────────┘ 
         ▼
+---------------------+
| --speed ENABLED     |
| Skip Timestamps     |
+---------------------+
         │
         ▼
+-----------------------------------+
| Raw Frame Extraction [No Delay]   |
| - No Timestamp Sync               |
| - No Temporal Modeling            |
+-----------------------------------+
         │
         ▼
+-----------------------------------+
| Rapid Frame-level Report          |
| - Fast Visual Summary             |
| - No Time-Aware Structure         |
+-----------------------------------+

→ 光速穿梭模式直接跳过时间对齐与阶段缓冲机制，实现极致的帧级分解性能。
→ 推荐在多视频预处理、批量检测、初步内容筛选等任务中使用。
```

#### 📔 应用场景:
- 在需要快速生成报告而不关心时间戳的场景中使用，例如初步数据分析或快速检测。
- 开启高效拆帧功能以便捕获更多细节，或关闭以减少处理时间和资源消耗。
#### 📔 实际应用: 
```
framix --speed
```

### ⚜️ 基石阵地 (`--basic`)
#### 📔 功能描述:
- 提供视频拆帧与精确时间戳注入的集成化流程，构建结构化帧级数据基础。
- 该模式适用于需要时间对齐的动态场景分析，有助于后续事件定位、节奏识别及时序建模等任务。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 启动增强型拆帧模式，此模式下将对每个视频帧进行时间戳注入，确保每帧数据的时间信息精准无误。适用于需要进行时间敏感分析或复杂视频编辑的应用场景。
- **关闭**: 维持基础的视频拆帧功能，不进行时间戳加载，优化常规视频处理的速度和资源效率。

```
+----------------------------------------------------------------------------+
|                      VIDEO FRAME ANALYSIS MODES IN FRAMIX                  |
+----------------------------------------------------------------------------+

     ┌───────────────────┐
     │    Video Input    │
     └─────────┬─────────┘
               ▼
+------------------------------+
|       FRAME SPLITTING        |
+------------------------------+
               ├───────────────────────────┬────────────────────────────┐
               ▼                           ▼                            ▼
     +-------------------+        +-----------------+          +-------------------+
     | --basic ENABLED   |        | --keras ON      |          | --basic DISABLED  |
     | Timestamping      |        | Deep Analysis   |          | Fast Split        |
     +-------------------+        +-----------------+          +-------------------+
               │                           │                            │
               ▼                           ▼                            ▼
     +-------------------+        +-----------------------+    +-------------------+
     | Frame + Timestamp |        | Keyframe Detection    |    | Raw Frames        |
     | Injection         |        | Semantic Segmentation |    | No Metadata       |
     +-------------------+        +-----------------------+    +-------------------+
               │                           │
               ▼                           ▼
     +-----------------------+    +-----------------------+
     | Time-Aligned Frame Set|    | Smart Video Breakdown |
     +-----------------------+    +-----------------------+

→ 基石阵地 适用于精密对时场景，例如行为识别、信号重建、动态建模。
→ 思维导航 适用于模型驱动场景，例如智能摘要、特征聚焦、自动标注。
→ 两者均可作为 Framix 后续分析（如阶段分类/报告生成）的输入来源。
```

#### 📔 应用场景:
- 适用于专业视频分析工作，如行为识别、场景重建等需要精确时间信息的高级应用。
#### 📔 实际应用: 
```
framix --basic
```

### ⚜️ 思维导航 (`--keras`)
#### 📔 功能描述:
- 基于深度学习模型对视频帧进行智能解构分析，融合帧级拆解与时序识别。
- 自动识别关键帧区间（起始与终止帧），适用于内容聚焦、事件检测与智能视频摘要等场景。
- 支持时间戳注入与特征感知，显著提升视频分析的自动化水平与语义理解能力。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 激活深度模型分析，此模式下系统将自动识别并标记视频的关键帧，优化内容提取和后续处理流程。特别适合于需要自动视频编辑、事件检测或行为分析的复杂应用场景。
- **关闭**: 执行标准的拆帧和时间戳加载过程，不引入模型分析，适用于不需深度分析的标准视频处理任务。

```
+------------------------------------------------------+
|        DEEP LEARNING-ENABLED VIDEO FRAME ANALYSIS    |
+------------------------------------------------------+

[Standard Mode (--keras OFF)]
┌─────────────────────┐
│ Video Input         │
└──────┬──────────────┘
       ▼
┌─────────────────────┐
│ Frame Splitting     │
└──────┬──────────────┘
       ▼
┌─────────────────────┐
│ Timestamp Injection │
└──────┬──────────────┘
       ▼
    [Output]

[Keras Mode (--keras ON)]
┌─────────────────────┐
│ Video Input         │
└──────┬──────────────┘
       ▼
┌────────────────────────────┐
│ Deep Model Inference       │
│ (CNN / Sequential)         │
└──────┬─────────────────────┘
       ▼
┌────────────────────────────┐
│ Keyframe Detection         │
│ + Event Recognition        │
└──────┬─────────────────────┘
       ▼
┌────────────────────────────┐
│ Smart Timestamping         │
└──────┬─────────────────────┘
       ▼
[Optimized Output]

→ 自动提取关键时段，适合智能剪辑、异常行为识别、事件摘要
→ 降低人工标记需求，提升效率与准确度
```

```
┌────────────┐     ┌───────────────┐     ┌────────┐
│  --speed   │ ──▶ │ ID            │ ──▶ │ Report │
└────────────┘     └───────────────┘     └────────┘

┌────────────┐     ┌───────────────┐     ┌───────────┐     ┌────────┐
│  --basic   │ ──▶ │ ID Timestamps │ ──▶ │ Structure │ ──▶ │ Report │
└────────────┘     └───────────────┘     └───────────┘     └────────┘

┌────────────┐     ┌───────────────┐     ┌───────────┐     ┌──────────┐     ┌────────┐
│  --keras   │ ──▶ │ ID Timestamps │ ──▶ │ Structure │ ──▶ │ AI model │ ──▶ │ Report │
└────────────┘     └───────────────┘     └───────────┘     └──────────┘     └────────┘
```

#### 📔 应用场景:
- 可以显著提高视频分析的精度和操作效率，特别是在处理大规模视频数据时，能够有效地减少人工干预和处理时间。
#### 📔 实际应用: 
```
framix --keras
```

---

## 🔰 视控精灵

### ⚜️ 独立驾驭 (`--alone`)
#### 📔 功能描述:
- 在多任务并行录制环境中，独立控制指定设备的录屏终止流程。
- 支持多设备并发时的定向控制，有效提升设备管理的粒度与任务调度的灵活性。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 启用独立控制，可以针对正在运行的设备独立停止录屏，便于生成与特定任务相关的录屏内容。
- **关闭**: 录屏功能将跟随整个系统或所有应用统一停止，适用于整体展示或演示环境。

```
+----------------------------------------------------+
|           MULTI-DEVICE RECORDING CONTROL           |
+----------------------------------------------------+

[Without --alone]
┌─────────────┐  ┌─────────────┐
│ Device A    │  │ Device B    │
│ [REC]       │  │ [REC]       │
│             │  │             │
└────┬────────┘  └────┬────────┘
     │                │
     └───────┬────────┘
             ▼
        [GLOBAL STOP] → 所有录屏终止

[With --alone]
┌─────────────┐  ┌─────────────┐
│ Device A    │  │ Device B    │
│ [REC]       │  │ [REC]       │
│             │  │             │
└────┬────────┘  └────┬────────┘
     │                │
     ▼                ▼
[STOP A ONLY]    [KEEP RECORDING]

→ 允许对每个设备的录音会话进行精确控制。
→ 在并发任务、有针对性的内容创建或实时切换中很有用。
```

#### 📔 应用场景:
- **游戏录屏**: 用户可以在游戏过程中独立控制录屏停止，以捕捉最精彩的游戏瞬间，而不受其他后台应用影响。
- **教学演示**: 在进行教学或演示应用操作时，能够精确控制每个步骤的录屏起止，制作出更为清晰和专业的教程视频。
- **多任务操作**: 在处理多任务时，用户可以选择只录制关键应用的操作过程，避免不相关应用的干扰，提升录屏内容的相关性和质量。
#### 📔 实际应用: 
```
framix --alone
```

### ⚜️ 静默守护 (`--whist`)
#### 📔 功能描述:
- 启动无提示录制模式，确保录制过程在用户界面完全静默，屏蔽所有系统投屏与录屏提示。
- 适用于数据采集、隐私保护或干扰最小化场景，保障录制过程的隐蔽性与完整性。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 激活静默录制，视频录制过程中不显示任何投屏或操作指示，实现完全隐蔽的背景录制。
- **关闭**: 录制视频时界面上将显示投屏或录屏状态，适用于用户需要可视反馈的情境。

```
+---------------------------------------------+
|         SILENT RECORDING COMPARISON         |
+---------------------------------------------+

[Without --whist]
┌─────────────┐
│ ● REC       │   ← 可见的投屏
│             │   ← 通知叠加
│             │
└─────────────┘
用户在屏幕上看到录制活动。

[With --whist]
┌─────────────┐
│             │   ← 无指示，静默模式
│             │   ← 没有视觉提示
│             │
└─────────────┘
用户界面保持不受干扰。

→ 录制过程中不显示任何 UI 提示、图标或覆盖。
→ 非常适合背景记录、隐秘捕获或 UX 测试。
```

#### 📔 应用场景:
- **隐私保护**: 在涉及敏感信息或私人环境的录制时，可以开启静默录制，确保录制活动不引起注意或干扰。
- **用户体验测试**: 开发者或测试人员在进行应用或服务的用户体验测试时，使用静默录制来获取真实用户交互过程，无需用户意识到正在进行录制。
- **安全演练**: 在进行安全演练或监控测试时，使用静默录制来模拟真实的监控场景，评估人员对非常规活动的反应和处理。
#### 📔 实际应用: 
```
framix --whist
```

---

## 🔰 显示布局

### ⚜️ 映界之门 (`--alter`)
#### 📔 功能描述:
- 指定切换至目标显示器，灵活迁移录制或投屏窗口，适配多屏环境操作。
- 通过明确的显示器编号，控制录制/投屏在不同显示器间的布局，实现多场景、多任务自由切换。
#### 📔 参数说明: 
- 一个可选的正整数，默认为`0`（主屏）。
- **指定编号**: 将录制/投屏窗口切换至对应编号的显示器，便于在多屏系统中精确控制输出位置。
- **默认编号0**: 如果未提供参数，窗口将保持在默认主屏显示。

```
+–––––––––––––––––––––––––––––––+
|   SCREEN SWITCHING EXAMPLES   |
+–––––––––––––––––––––––––––––––+

[Without –alter]
┌─────────────┐
│ Primary     │   ← 默认主屏显示
│ Display     │
└─────────────┘
窗口在系统默认主显示器上运行。

[With –alter 2]
┌─────────────┐
│ Secondary   │   ← 切换到第二块扩展屏
│ Display     │
└─────────────┘
窗口迁移至指定扩展显示器，布局灵活。

→ 支持多显示器环境中的自由布局与快速切换。
→ 适合演示、监控、多任务处理等多场景应用。
```

#### 📔 应用场景:
- **多屏演示**: 在会议、展示或培训环境下，将录制或演示内容灵活切换到不同屏幕，提升观众体验。
- **开发测试**: 开发者在多显示器配置中，按需切换录制窗口至目标屏幕，便于调试与记录。
- **任务调度**: 在操作复杂的多任务环境中，自由迁移窗口，优化屏幕资源配置，提升工作流效率。

#### 📔 实际应用: 
```
framix –-alter 1
```

---

## 🔰 像素工坊

### ⚜️ 均衡节奏 (`--alike`)
#### 📔 功能描述:
- 通过统一化视频长度来提升内容的一致性和观看体验。
- 自动裁剪每一组视频至最短录制时间，确保所有视频段落的时间长度一致，从而在多视频项目中实现视觉和时间的均衡。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 裁剪掉超出最小录制时间的部分，使每个视频段落长度一致，提升整体项目的整洁性和专业感。
- **关闭**: 维持视频原有长度，不进行自动裁剪，保持视频的完整性和原始记录。

```
+------------------------------+
|       EQUALIZED LENGTH       |
+------------------------------+

Video A:  [============] 12s   ┐
Video B:  [==============] 14s │
Video C:  [========]      8s   │
                               ▼
        Min Duration Detected: 8s

Result After --alike Enabled:
Video A:  [    ========] 8s
Video B:  [      ========] 8s
Video C:  [========] 8s

说明
并不是所有的录制行为都是同一时间拉起的，最后拉起的时间最短。
最先拉起的将裁切前面的部分，因为前面的时间都是在等待后面的录制拉起，直到最后一个录制拉起，此段时间才是有意义的。  
所有片段均剪辑至最短的视频时长，确保多视频项目之间的时间一致性。
```

#### 📔 应用场景:
- **多镜头剪辑**: 在处理由多个设备或角度拍摄的视频时，可以通过均衡节奏确保每个视角的视频长度一致，方便进行同步播放和编辑。
- **教育内容制作**: 制作教学视频时，均衡各视频片段的长度，确保教学内容在时间上的均匀分配，提升学习效率。
- **会议记录与整理**: 对于会议的多段视频记录，使用均衡节奏处理后，易于整理和回顾，也便于将会议内容整合成标准化的格式。
#### 📔 实际应用: 
```
framix --alike
```

### ⚜️ 平行映射 (`--shine`)
#### 📔 功能描述:
- 允许用户在多个视频分析任务之间创建并行处理通道，从而提高视频处理效率。
- 通过开启该功能，系统可以同时对多个视频进行并行分析，在减少总处理时间的同时，确保分析结果的一致性和同步性。
- 该功能特别适合处理大规模的视频数据集或需要实时分析的视频流。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 激活平行映射功能，系统将利用多进程或多线程技术同时处理多个视频任务，从而加速分析过程。
- **关闭**: 不启用平行映射功能，系统将按顺序逐一处理视频任务，适用于对处理顺序有严格要求的分析场景。

```
┌────────────────────────────────────────────┐
│              --shine function              │
├────────────────────────────────────────────┤
│                                            │
│        Tasks                               │
│                                            │
│        Video 1  ───► Alynex A              │
│        Video 2  ───► Alynex A              │
│        Video 3  ───► Alynex A              │
│                                            │
├────────────────────────────────────────────┤
│                                            │
│        Tasks on --shine                    │
│                                            │
│        Video 1  ───► Alynex A [Child P]    │
│        Video 2  ───► Alynex B [Child P]    │
│        Video 3  ───► Alynex C [Child P]    │
│                                            │
└────────────────────────────────────────────┘

说明
- 启用 `--shine` 后，Framix 将为每个视频任务分配独立的并行执行单元。
- 适合处理大规模视频或需要实时反馈的任务。
```

#### 📔 应用场景:
- **大量视频分析**: 在需要同时分析多个视频源的场景中，如监控系统、数据中心视频分析，或大型视频内容库的自动化审核。
- **实时视频处理**: 在直播或视频会议场景中，平行映射功能可以确保多路视频流同时被分析和处理，提供及时的反馈和监控。
- **视频内容创作**: 对多角度拍摄的视频素材进行同步处理和分析，确保编辑过程的效率和最终内容的连贯性。
#### 📔 实际应用: 
```
framix --shine
```

---

## 🔰 数据智绘

### ⚜️ 集群视图 (`--group`)
#### 📔 功能描述:
- 针对多设备协同执行的任务场景，为每个设备单独生成详尽的分析报告，实现设备级的数据隔离与可追溯性。
- 此功能适用于集群化部署、远程设备控制与分布式数据采集场景，有助于定位性能瓶颈、数据偏差与系统异常，提升系统的可观测性与可维护性。
- 支持动态扩展设备并行度，确保在异构设备或高并发分析中保持准确性与稳定性。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 启用独立报告生成，确保在多设备协同作业中，每台设备的输出、性能及异常都能被单独跟踪和评估，提升个体设备管理的精确度和效率。
- **关闭**: 所有设备共享一个统一的报告，适用于设备性能和输出大体一致的情况，可以简化管理和监控过程。
#### 📔 应用场景:
- **数据中心监控**: 在数据中心或大规模服务器环境中，使用集群视图来监控和记录每台服务器的运行状况，有助于快速识别和响应具体机器的问题。
- **多摄像头监控系统**: 在安防或监控系统中，对每个摄像头生成独立报告，有利于分析特定位置或角度的视觉数据，提高安全监控的有效性。
- **智能家居管理**: 在智能家居系统中，为每个智能设备生成独立的性能和使用报告，帮助家庭用户更好地理解和优化各设备的使用和能耗。
#### 📔 实际应用:
```
framix --group
```

### ⚜️ 鉴证之书 (`--total`)
#### 📔 功能描述:
- 用于指定最终分析报告的输出路径，系统将在该位置生成包含各类分析结果、图表与统计信息的综合性报告文件。
- 此功能便于统一存档与后期审阅，可结合自动化流水线，将分析结果同步至远程存储、报告系统或质量评估平台，提升流程集成度与可追踪性。
#### 📔 参数说明: 
- 一个有效的文件夹路径。
- `total`参数被指定时，分析报告将生成在指定的文件夹路径内。这确保所有的分析结果可以集中管理和存档，便于后续的查阅和审计。
#### 📔 应用场景:
- **项目管理**: 在一个项目中，生成综合报告并存储在特定目录下，以便项目团队能够方便地访问和审阅所有分析结果。
- **合规审计**: 在需要进行合规审查的环境中，集中存储所有分析报告，以满足法规要求和审计需求。
- **研究分析**: 在科研项目中，将所有实验数据和分析结果汇总存储，便于进行全面的数据分析和结果对比。
#### 📔 实际应用: 
```
framix --total path\to\your\directory
```

---

## 🔰 图帧先行

### ⚜️ 尺寸定制 (`--shape`)
#### 📔 功能描述:
- 支持自定义输出视频的尺寸（宽度 × 高度），以适应不同分发平台或终端设备的分辨率要求。
- 在确保视觉质量的前提下，有效优化处理效率与传输带宽，占用更少存储空间。
- 适用于批量压缩、格式转换或模型推理场景中的尺寸归一化处理。
#### 📔 参数说明: 
- **形式** `--shape WIDTH,HEIGHT`
- **类型** 两个正整数，分别代表目标帧的 **宽度** 与 **高度**
- `shape`参数被指定时，视频每一帧都会被重新调整到这个特定的宽高比（例如，`W x H`）。这个操作常用于需要统一视频输入大小的场景，例如机器学习模型训练，其中输入尺寸必须一致。
- `shape`通常以像素为单位指定，例如`1920, 1080`，在保持原始宽高比的前提下自动调整为最合适尺寸。这确保了图像或视频在调整后不会出现扭曲或失真，保持了视觉内容的完整性和美观。
- 推荐范围
  - 宽度（W）`160 ~ 3840`
  - 高度（H）`120 ~ 2160`
- 建议使用 **16:9** 或 **4:3** 等标准宽高比，避免拉伸或黑边

```
原始帧尺寸: 1280x720（16:9）
           │
     ┌─────▼─────┐
     │ reshape() │ --shape=300,600
     └─────┬─────┘
           ▼
调整后尺寸: 300x600（5:10）
           │
     ┌─────▼─────┐
     │   model   │ → 分析 / 训练 / 转码
     └───────────┘

说明
- 图像会被直接缩放至指定尺寸，而非保持比例裁剪。
- 适用于需要固定输入尺寸的任务（如 CNN 模型、YOLO）。
```

| 宽度 (W) | 高度 (H) | 说明             | 建议用途          |
|--------|--------|----------------|---------------|
| `1920` | `1080` | Full HD (16:9) | 通用高清视频、平台兼容性强 |
| `1280` | `720`  | HD (16:9)      | 直播、社交媒体       |
| `640`  | `480`  | SD (4:3)       | 老旧设备、低分辨率处理   |
| `300`  | `600`  | 非标准比例          | 实验性视觉调试、竖屏测试  |
| `3840` | `2160` | 4K Ultra HD    | 高端输出、细节分析     |

#### 📔 应用场景:
- **视频制作与编辑**: 在制作视频内容时，经常需要将视频调整到特定的分辨率或大小，以满足不同平台的上传标准。
- **机器学习和视频分析**: 在进行视频内容分析或机器学习模型训练时，通常需要输入尺寸一致的视频帧。
- **网络传输**: 在进行视频流传输时，根据网络条件调整视频的分辨率和大小，可以优化传输效率和质量。
#### 📔 实际应用: 
```
framix --shape 300,600
```
  
### ⚜️ 变幻缩放 (`--scale`)
#### 📔 功能描述:
- 支持对视频帧进行等比或非等比缩放处理，以调整整体画面比例或适配特定视觉需求。
- 可用于降低分辨率以提高处理速度，或放大图像以增强细节观察。
- 缩放算法可与后续图像分析或模型推理任务协同优化，提高整体流程效率。
- 在保持画面清晰度与比例合理性的基础上，有效控制资源消耗和输出体积。
#### 📔 参数说明: 
- 一个可选的浮点数，按比例调整视频帧的尺寸，默认值 0.5（等比缩小为原始尺寸的一半），取值范围 0.1 ～ 1.0。
- 非常适用于在不改变视频宽高比的前提下，调整视频文件的大小，这在需要减少文件大小或适应不同带宽要求的在线流媒体服务中尤其有用。
- 取值 **< 1.0** 图像缩小，适合加速处理、节省资源。
- 取值 **= 1.0** 图像不缩放，保持原始尺寸。
- 取值 **> 1.0** 图像放大，可能增加模糊感或计算压力。
- 超过 `1.5` 不建议使用，因可能带来图像模糊或处理不稳定。
- 小于 `0.1` 可能导致图像信息丢失或压缩严重。

```
原始帧尺寸: 1920x1080
           │
     ┌─────▼─────┐
     │   Scale   │ --scale=0.5
     └─────┬─────┘
           ▼
处理后尺寸: 960x540
           │
     ┌─────▼─────┐
     │  Analyze  │ → 模型输入、检测、可视化等
     └───────────┘

说明
- 缩放是在不改变宽高比的前提下进行的。
- 所有图像数据（如边缘、纹理、结构）按比例缩放。
- 可配合其他处理参数（如灰度化、压缩）联合使用。
```

| `--scale` 取值 | 缩放效果     | 应用建议            |
|--------------|----------|-----------------|
| `0.1 ~ 0.3`  | 强烈缩小     | 快速预览、低带宽传输      |
| `0.4 ~ 0.6`  | 中度缩小（推荐） | 平衡速度与质量         |
| `0.7 ~ 0.9`  | 轻微缩小     | 保持清晰度同时节省计算资源   |
| `1.0`        | 不变       | 保留原始分辨率         |
| `1.1 ~ 1.5`  | 轻微放大     | 模型推理需要更大输入时谨慎使用 |

#### 📔 应用场景:
- **视频制作与编辑**: 在制作视频内容时，经常需要将视频调整到特定的分辨率或大小，以满足不同平台的上传标准。
- **机器学习和视频分析**: 在进行视频内容分析或机器学习模型训练时，通常需要输入尺寸一致的视频帧。
- **网络传输**: 在进行视频流传输时，根据网络条件调整视频的分辨率和大小，可以优化传输效率和质量。
#### 📔 实际应用: 
```
framix --scale 0.5
```

### ⚜️ 时刻启程 (`--start`)
#### 📔 功能描述:
- 指定视频片段的起始时间点，仅分析或处理该时间点之后的内容。
- 可用于跳过片头、定位关键时间段，适配大文件裁剪或任务加速。
#### 📔 参数说明: 
- 定义视频裁剪的起始时间点。
- 如果指定了有效的 `start` 值（即在视频总时长内），裁剪将从此时间点开始。如果 `start` 值无效或未指定，裁剪从视频的开始处（即时间点0）开始。
#### 📔 应用场景:
- 例如，在监控视频分析中，可能需要提取发生特定事件的时间段；在视频编辑和制作中，可以通过这些参数精确控制视频片段的选取。
- 通过程序化地设定这些参数，可以自动化视频处理工作流，提高效率并减少人工干预的需求。
#### 📔 实际应用: 
```
framix --start 00:00:05
framix --start 00:00:05.166666
framix --start 2
framix --start 2.166666
```

### ⚜️ 时光封印 (`--close`)
#### 📔 功能描述:
- 设置视频片段的终止时间点，仅处理该时间点之前的内容。
- 常用于跳过片尾、控制分析范围或预留系统资源。
#### 📔 参数说明: 
- 定义视频裁剪的结束时间点。
- 如果指定了有效的 `close` 值，并且该值大于 `start` 值且在视频的总时长内，裁剪将在此时间点结束。
- 如果 `close` 值小于 `start` 值或未指定，或者 `close` 值超出了视频的总时长，结束点将设置为视频的总时长。
- 裁剪片段至少需要有最小长度（0.09秒），否则可能返回无效。
#### 📔 应用场景:
- 例如，在监控视频分析中，可能需要提取发生特定事件的时间段；在视频编辑和制作中，可以通过这些参数精确控制视频片段的选取。
- 通过程序化地设定这些参数，可以自动化视频处理工作流，提高效率并减少人工干预的需求。
#### 📔 实际应用: 
```
framix --close 00:00:15
framix --close 00:00:15.166666
framix --close 15
framix --close 15.166666
```

### ⚜️ 持续历程 (`--limit`)
#### 📔 功能描述:
- 指定从起始时间起要分析的持续时长，自动截取对应长度的视频段落。
- 与 `--start` 搭配使用时，可精准控制处理窗口，避免冗余计算。
#### 📔 参数说明: 
- 定义从 `start` 时间点开始的持续时间。
- 如果 `close` 未指定，则 `limit` 用于确定裁剪的持续时间。如果从 `start` 时间点开始的 `limit` 持续时间内有效（即不超过视频的总时长），则裁剪将持续这么长时间。
- 如果 `limit` 指定的时间加上 `start` 时间超出了视频的总时长，裁剪持续时间将调整为从 `start` 到视频结束的时间。
- 类似于 `close`，`limit` 定义的持续时间也需要满足最小长度要求。
#### 📔 应用场景:
- 例如，在监控视频分析中，可能需要提取发生特定事件的时间段；在视频编辑和制作中，可以通过这些参数精确控制视频片段的选取。
- 通过程序化地设定这些参数，可以自动化视频处理工作流，提高效率并减少人工干预的需求。
#### 📔 实际应用: 
```
framix --limit 00:00:03
framix --limit 00:00:03.166666
framix --limit 3
framix --limit 3.166666
```

### ⚜️ 朦胧幻界 (`--gauss`)
#### 📔 功能描述:
- 使用高斯模糊算法对图像进行卷积平滑处理，有效削弱图像噪声与边缘锐度。
- 常用于背景虚化、艺术滤镜、前处理降噪等场景，营造柔和梦幻的视觉氛围。
#### 📔 参数说明: 
- 一个可选的浮点数（默认不进行模糊），取值范围 0.0 ~ 2.0，指定高斯模糊的强度。数值越大，图像越模糊。
- 推荐使用范围为 0.3 ~ 2.0，过高值将严重损失内容识别性。


```
┌────────────┐       ┌────────────────┐
│            │       │                │
│ Kernel 3x3 │       │                │
│  █▒▒▒▒▒▒▒▒ │       │                │
│  ▒██▒▒▒▒▒▒ │       │    Old Image   │
│  ▒▒▒██▒▒▒▒ │  →→→  │   ┌──────────┐ │
│  ▒▒▒▒▒██▒▒ │ Convo │   │ Pic      │ │
│  ▒▒▒▒▒▒▒█▒ │       │   └──────────┘ │
│            │       │     [Input]    │
└────────────┘       └────────────────┘  
      +
┌────────────┐
│ Kernel 5x5 │
│  ███▒▒▒▒▒▒ │
│  ██▒██▒▒▒▒ │
│  ▒██▒██▒▒▒ │
│  ▒▒▒██▒██▒ │
│  ▒▒▒▒▒███▒ │
└────────────┘    
      ↓    
┌────────────────┐
│                │
│  New Image     │
│ ┌────────────┐ │
│ │ G Pic      │ │
│ └────────────┘ │
│   [Output]     │
└────────────────┘

说明
- 左侧为不同大小的高斯卷积核（Kernel）。
- 中间为“卷积”操作（Convolution）。
- 右侧展示图像从清晰到模糊的处理效果。
```

| 值范围       | 效果说明           | 建议使用场景           |
|-----------|----------------|------------------|
| 0.0 ~ 0.3 | 极轻模糊，几乎无感知差异   | 降噪预处理、轻柔视觉过渡     |
| 0.4 ~ 1.0 | 中等模糊，细节有明显柔化   | 人像背景虚化、内容聚焦      |
| 1.1 ~ 2.5 | 明显模糊，图像轮廓开始失真  | 模拟梦境感、艺术滤镜、柔光镜效果 |
| > 2.5     | 强烈模糊，仅保留色块与轮廓感 | 隐私保护、背景遮挡、抽象效果场景 |

#### 📔 应用场景:
- **人像摄影**: 在人像摄影中，通过模糊背景以突出主体，增加照片的艺术感。
- **隐私保护**: 用于隐私保护，对敏感信息进行模糊处理，例如在上传社交媒体的照片中隐藏个人信息。
- **视频制作**: 在视频制作中，为过渡场景或梦境序列添加模糊效果，增强视觉冲击力。
#### 📔 实际应用: 
```
framix --gauss 0.5
```

### ⚜️ 边缘觉醒 (`--grind`)
#### 📔 功能描述:
- 基于边缘增强或锐化算法（如拉普拉斯或高通滤波），提高图像边缘与纹理的清晰度。
- 适用于修复模糊图像、强化结构轮廓，或在特定分析任务中凸显细节信息。
#### 📔 参数说明: 
- 一个可选的浮点数（默认不进行锐化），取值范围 0.0 ~ 2.0，指定锐化的强度。数值越高，图像的锐化效果越明显。
- 合理范围建议
  -  0.3 ~ 1.0 轻微锐化，适用于多数视频增强场景。
  -  1.0 ~ 1.5 中等锐化，适合细节强调（如结构增强、人脸突出）。
  -  1.5 ~ 2.0 强锐化，可能带来一定的噪点或过度效果，需谨慎使用。
  -  **不支持负数** 负数等效于图像模糊，违背锐化初衷，已在参数逻辑中禁用。

```
flowchart TD
    A[原始帧图像] --> B[图像压缩 / 预处理（可选）]
    B --> C[锐化滤波器<br/>unsharp filter]
    C --> D[锐化强度调节<br/>luma_amount = --grind]
    D --> E[边缘增强结果帧]
    E --> F[后续处理 / 分析模块]

图示说明
    •	A → B 图像在进入锐化流程之前，可能经过预处理，如灰度化、压缩、裁剪等。
    •	B → C 使用 FFmpeg 的 unsharp 滤镜对图像进行锐化处理。
    •	C → D 通过参数 --grind 控制 luma_amount 的值，增强亮度通道的边缘强度。
    •	D → E 输出边缘更清晰、细节更突出的图像。
    •	E → F 可将结果传递给分析模型、分类器或生成报告模块。
```

| 数值范围      | 强度级别 | 效果描述           | 推荐用途        |
|-----------|------|----------------|-------------|
| 0.0       | 无锐化  | 保留原始图像         | 比对基准、不做处理   |
| 0.1 ~ 0.5 | 轻度锐化 | 细微增强，改善轻度模糊    | 视频对话、人脸图像增强 |
| 0.6 ~ 1.0 | 中度锐化 | 提升边缘轮廓，突出纹理细节  | 动作捕捉、图像结构识别 |
| 1.1 ~ 1.5 | 强烈锐化 | 强化纹理边缘，对比增强明显  | 医疗影像、工业检测   |
| 1.6 ~ 2.0 | 超强锐化 | 可能造成过度锐化，需谨慎使用 | 特效滤镜、科研图像增强 |

#### 📔 应用场景:
- **改善清晰度**: 用于改善低分辨率图像的清晰度，适用于放大显示或高质量打印。
- **医疗影像处理**: 在医疗影像处理中，增强图像细节，帮助医生更好地分析和诊断。
- **监控视频细节**: 在监控视频中增强细节，以更清楚地识别人脸或车牌等关键信息。
#### 📔 实际应用: 
```
framix --grind 0.1
```

### ⚜️ 频率探测 (`--frate`)
#### 📔 功能描述:
- 控制视频处理过程中的帧率采样频率，用于平衡图像精度与计算负载。
- 常用于视频加速预览、动作识别、性能优化等任务中，尤其适合需要高帧细节的分析场景。
#### 📔 参数说明:
- 一个可选的整数，表示目标帧率（Frames Per Second, FPS），默认值为 60，取值范围 30 ~ 60。
- 帧率越高，图像变化越细腻，但计算开销越大。
- 帧率越低，处理速度提升，但可能丢失细节。

```
假设视频播放时间为 1 秒，不同帧率下的帧分布如下

时间轴（单位 秒）
|----|----|----|----|----|----|----|----|----|----|
0   0.1  0.2  0.3  0.4  0.5  0.6  0.7  0.8  0.9  1.0

FPS = 30 （每秒 30 帧）:
帧分布：每帧间隔约 33ms，细节捕捉较为平衡
帧序列：[■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■]

FPS = 60 （每秒 60 帧）:
帧分布：每帧间隔约 16ms，动作更平滑，细节更丰富
帧序列：[■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■]

FPS = 15 （每秒 15 帧）:
帧分布：每帧间隔约 66ms，节省资源但画面较卡顿
帧序列：[■■■■■■■■■■■■■■■■■■■■■■■■]

说明
- 帧率越高，画面越流畅，但计算与存储开销越大；
- 帧率越低，处理效率更高，但运动可能不连续；
- 推荐值 **30 FPS** 为常规标准，**60 FPS** 适合高速运动场景。
```

| 帧率 (`--frate`) | 图像变化捕捉 | 视觉平滑度 | 计算资源消耗 | 推荐应用场景    |
|----------------|--------|-------|--------|-----------|
| 30             | 低      | 一般    | 低      | 教学视频、演示回放 |
| 45             | 中      | 良好    | 中      | 普通剪辑、信息抽取 |
| 60             | 高      | 极佳    | 高      | 动作识别、竞技分析 |

#### 📔 应用场景:
- **动作场景分析**: 如游戏实录、体育竞技，建议使用高帧率 60。
- **静态变化检测**: 如演示视频或教学剪辑，可使用较低帧率 30 加快处理。
- **性能压缩优化**: 在资源受限环境中，适当降低帧率以减少内存和CPU压力。
#### 📔 实际应用: 
```
framix --frate 60
```

---

## 🔰 智析引擎

### ⚜️ 加速跳跃 (`--boost`)
#### 📔 功能描述: 
- 控制视频帧的抽样与处理节奏，特别是在选取关键帧和处理这些帧时如何优化和加速这一过程。
- 通过智能跳帧与关键帧优选机制，加速分析流程，提升处理效率，尤其适用于长视频或资源受限场景。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。 
- **开启**: 优化视频分析过程，加速关键帧的处理。这通常在需要精确分析或处理每个重要变化点时使用，例如在高动态视频分析或高级视频编辑中。
- **关闭**: 处理每一帧，适用于需要全面分析整个视频内容的场景，如全帧分析或当不需要特别优化处理速度时。

```
原始视频帧序列:
[ S S S U U S S U U U S S ]  (S: 稳定帧，U: 不稳定帧)

--boost 开启后:
        ↓
[     U U     U U U     ]   => 仅保留有意义变化段进行处理
```

- 用于跳过连续稳定阶段的帧，专注于分析非稳定阶段的关键变化帧，从而加速处理流程。
- 通过智能跳帧机制和不稳定阶段优先分析，跳过重复/稳定内容，显著提升长视频处理效率。
- 启动后，系统将自动过滤长时间无变化的片段，仅保留视觉内容变动剧烈的部分进行分析。

#### 📔 应用场景
- **高动态视频分析**: 在高动态场景中，视频内容变化迅速且频繁。例如，体育比赛、动作片或快速移动的摄像画面。使用 `--boost` 功能，可以优化关键帧的处理，加快分析速度，确保对关键动作和变化的精准捕捉。
- **高级视频编辑**: 在高级视频编辑中，如剪辑、特效处理和转场效果，往往需要对视频的关键帧进行精细处理。开启 `--boost`，可以显著提高处理效率，节省编辑时间。
- **安全监控**:在安全监控系统中，快速识别和处理异常事件（如闯入、打斗）至关重要。通过 `--boost` 加速帧处理，可以迅速定位和分析关键事件，提升系统响应速度。
#### 📔 实际应用: 
```
framix --boost
```

### ⚜️ 彩绘世界 (`--color`)
#### 📔 功能描述: 
- 可以根据具体的应用需求控制是否启用彩色通道进行处理。
- 在无需色彩信息的场景下可选择灰度模式，以降低计算负担并提升处理速度，实现性能与视觉需求之间的灵活权衡。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 视频帧保持其原始的彩色状态。
- **关闭**: 视频帧将被转换成灰度图像，即单色调的图像。

```
开启 --color
┌────────────┐
││││││││││││││   →   保留颜色通道，适用于颜色敏感任务
└────────────┘

关闭 --color（默认）
┌────────────┐
│            │   →   降维处理，适用于通用结构分析
└────────────┘
```

#### 📔 应用场景:
- **性能优化**: 转换视频帧为灰度图像可以减少数据处理量，从而提高算法运行速度，适用于不依赖颜色信息的处理任务，如某些类型的运动检测、对象跟踪等。
- **数据简化**: 在需要分析视频内容而颜色信息不重要的情况下，去除彩色可以简化数据处理，例如在视频压缩或某些机器学习模型训练中减少输入特征的维度。
- **保留重要信息**: 在颜色信息对于任务至关重要的场景（如颜色识别、图像分割等），保留彩色信息是必须的。
#### 📔 实际应用: 
```
framix --color
```

### ⚜️ 序章开启 (`--begin`)
#### 📔 功能描述:
- 用于定位并选取视频中初始的不稳定阶段帧，作为分析或剪辑的起始点。
- 该参数可实现对内容开头的精细控制，适用于关键时刻的标注与后期处理。
#### 📔 参数说明: 
- `begin_stage,begin_frame`: 此参数接受一个逗号分隔的字符串。
- **begin_stage** 指的是希望开始处理的非稳定阶段的序号（通常根据视频分析得到），而 `begin_frame` 是该阶段内的具体帧序号。
- **begin_frame** 该阶段内第几帧（从 1 开始）。
- 实际上，**Framix** 会基于此前自动分析出的非稳定区间，定位到指定区块及帧序进行截断。

```
视频不稳定阶段划分如下（已由 Framix 自动分析）

┌────────┬────────────┬────────────┬────────────┐
│ stage0 │   stage1   │   stage2   │   stage3   │
│ frames │ frames ... │ frames ... │ frames ... │
└────────┴────────────┴────────────┴────────────┘
             ↑
          begin=1,1
表示从第 2 段区域的第 2 帧开始处理
```

#### 📔 应用场景:
- **视频编辑**: 在制作剪辑或高光时刻视频时，可以精确地选择动态或关键事件开始的帧。
- **行为分析**: 在进行运动或行为研究时，准确地标定行为开始的位置，对后续的数据分析至关重要。
- **机器学习数据标注**: 为机器学习训练准备数据时，精确选取视频中的特定帧可以作为标注的起点。
#### 📔 实际应用: 
```
framix --begin 0,1
```

### ⚜️ 终章落幕 (`--final`)
#### 📔 功能描述:
- 用于定义视频处理的终止点，支持通过 `final_stage` 或 `final_frame` 指定结束阶段或具体帧位置。
- 当参数设为 `-1` 时，表示自动选取视频的最后一个阶段或最后一帧，便于快速截取完整片段的末尾部分。
#### 📔 参数说明: 
- 通过提供一个字符串`final_stage,final_frame`，指定第 `final_stage` 个非稳定阶段的第 `final_frame` 帧。
- **final_stage** 指定结束阶段的索引编号（从 0 开始，-1 表示最后一个不稳定阶段）。
- **final_frame** 该阶段中的第几帧（从 1 开始，-1 表示该阶段的最后一帧）。
- -1,-1 表示从整个分析结果中，自动选取最后一阶段的最后一帧作为终点。
- 参数必须与 **Framix** 自动生成的不稳定阶段索引表相对应。

```
分析后的不稳定阶段（自动生成）

┌────────┬────────────┬────────────┬────────────┐
│ stage0 │   stage1   │   stage2   │   stage3   │
│ frames │ frames ... │ frames ... │ frames ... │
└────────┴────────────┴────────────┴────────────┘
                                         ↑
                                  final=-1,-1
                    表示处理截止到最后一阶段的最后一帧
```

#### 📔 应用场景:
- **视频制作**: 在创建视频的结尾片段或进行渐出效果时，精确地定义结束点。
- **科学研究**: 在进行时长测定或事件结束点的研究中，能够明确标记事件的结束帧。
- **教育内容制作**: 制作教学视频时，准确地结束一个教学单元或实验演示。
#### 📔 实际应用: 
```
framix --final=-1,-1
```

### ⚜️ 稳定阈值 (`--thres`)
#### 📔 功能描述:
- 用于设定图像帧之间结构相似性（SSIM）的判定阈值。
- 该值越高，对图像稳定状态的判定越严格，在视频剪辑、关键帧提取、稳定性检测等任务中提升图像变化识别的敏感度与精度。
#### 📔 参数说明: 
- 一个可选的浮点数，默认值为 0.98，取值范围 0.85 ~ 1.00（实际项目中建议通过可视化统计获取最优值）。
- 一般设置在 0.85 ~ 0.99 之间。
  - 数值越大
    - 判定为“稳定”的门槛更高。
    - 对变化更敏感，更容易检测出运动、切换、微小波动。
  - 数值越小
    - 更容易将变化小的片段也视为“稳定”。
    - 容忍度更强，更适合分析轻微变化或压缩过的视频。

```
结构相似度 (SSIM) 连续帧变化示意图（thres = 0.95）

       稳定            非稳定             稳定         
┌────────────────┬──────────────┬────────────────────┐
│                │              │                    │
│  SSIM ≈ 0.98   │  SSIM ≈ 0.91 │   SSIM ≈ 0.96      │
│  Frame 1 - 20  │  Frame 21-30 │   Frame 31 - 50    │
│                │              │                    │
└────────────────┴──────────────┴────────────────────┘
        ↑                ↑                 ↑
    > thres          < thres           > thres

判断结果
- [1 - 20] 稳定区间
- [21 - 30] 非稳定区间
- [31 - 50] 稳定区间
```

| 场景描述 | 推荐取值          | 说明                          |
|------|---------------|-----------------------------|
| 极高精度 | `0.98 ~ 0.99` | 适用于图像非常稳定、无压缩噪声或几乎无变化的视频。   |
| 一般精度 | `0.95 ~ 0.98` | 推荐范围，适合大多数高清、正常质量视频。        |
| 冗余处理 | `0.90 ~ 0.95` | 当视频存在轻微变化或压缩噪声时使用，避免误判为不稳定。 |
| 快速检测 | `< 0.90`      | 允许较大波动，适用于快速粗粒度过滤。          |

#### 📔 应用场景:
- 提供一个量化的界限来评估图像或视频帧的稳定性。
- 在处理视频数据时，通常希望去除那些由于摄像头抖动或场景变化造成的不稳定帧。
- 通过设置一个 SSIM 的阈值，可以有效地筛选出那些与参考帧相似度较高、变化不大的稳定帧。
- 在视频监控分析中，可能需要从一连串的视频帧中挑选出稳定的帧进行进一步分析，如人脸识别或事件检测。
- 在视频编辑或后期处理中，找出稳定的片段可以帮助进行更加平滑的转场或剪辑。
#### 📔 实际应用: 
```
framix --thres 0.97
```

### ⚜️ 偏移调整 (`--shift`)
#### 📔 功能描述:
- 定义视频区间匹配时的最大允许偏移容差，适用于对比两个片段之间的起止时间或帧编号差异。
- 该参数广泛用于多段拼接、场景变化识别及视频同步过程中，对容忍度进行灵活调控。
#### 📔 参数说明: 
- 一个可选的整数，默认值为 3（即允许合并的间隔帧数上限），取值范围 0 ~ 15。
- 对视频中轻微跳帧或编辑点模糊的段落，推荐设置 `--shift=1~2`。
- 设置为 1 ~ 3 可以更宽松地合并近似连续但中间有跳帧的小区间，常用于处理轻微丢帧、检测容忍等场景
- 对于要求精确分析的场景（如转场检测），建议使用默认值 `--shift=0`（必须完全连续）。
- 偏移值越小，相邻窗口之间重合度越高，有助于捕捉细微变动。
- 偏移值越大，则跳跃处理更强，适用于高节奏场景分析。
- 典型范围为 1~15，不建议太大，若偏移值设得过大，可能导致跳过关键过渡帧，影响分析完整性。

```
时间轴（帧）
|--- 稳定 ---|-- 不稳定 --|-- 稳定 --|-- 稳定 --|-- 不稳定 --|-- 稳定 --|
      ↑            ↑          ↑         ↑          ↑          ↑
  SSIM↑        SSIM↓      SSIM↑     SSIM↑      SSIM↓      SSIM↑
     >T           <T         >T        >T         <T         >T
      <-------- shift -------->

Legend:
- SSIM 当前帧区间结构相似度平均值
- T thres，稳定判断的阈值
- shift 容差值，允许两个稳定片段之间存在小段不稳定区域而仍被视为连续
```

```
A.end = 100
shift = 0 （严格连续）
--------------------------------------
B.start = 101    ✅ 可合并
C.start = 102    ❌ 无法合并
D.start = 103    ❌ 无法合并

shift = 1 （最多间隔1帧）
--------------------------------------
B.start = 101    ✅ 可合并
C.start = 102    ✅ 可合并
D.start = 103    ❌ 无法合并

shift = 2 （最多间隔2帧）
--------------------------------------
B.start = 101    ✅ 可合并
C.start = 102    ✅ 可合并
D.start = 103    ✅ 可合并
E.start = 104    ❌ 无法合并
```

| 应用场景 | 推荐 shift 值 | 描述说明                               |
|------|------------|------------------------------------|
| 精准检测 | 0          | 不允许任何间隔，用于严格识别阶段切换或变化边界。           |
| 抖动消除 | 1 ~ 3      | 适度容忍跳帧，适用于设备误差、小范围干扰等轻微不连续的情况。     |
| 稳定聚合 | 5 ~ 10     | 当帧率较高、内容连续但分布稀疏时，用于聚合本质上属于同一阶段的段落。 |

#### 📔 应用场景:
- 允许在合并视频片段时有更大的灵活性，尤其是在视频编辑或处理过程中，可能存在由于编码或切割导致的微小时间间隔。通过设置一个 `shift`，可以在不牺牲合并质量的前提下，容忍这些小间隔。
- 有助于处理实际视频数据时因帧率和时间码不准确导致的问题，使得视频处理过程更加健壮。
- 在视频编辑软件中，可以用来自动识别并建议可能的剪辑合并点，帮助编辑者更高效地组织视频序列。
- 在自动视频处理流程，如生成视频摘要时，可以利用此函数来决定哪些片段可以合并以创建更流畅的视频摘要。
#### 📔 实际应用: 
```
framix --shift 3
```

### ⚜️ 星线踏步 (`--slide`)
#### 📔 功能描述:
- 控制滑动窗口在视频帧序列中的推进步幅。
- 步幅越小，窗口间重叠度越高，有助于提升检测精度；步幅越大，推进速度更快，有利于大规模分析。
- 配合 `--scope`（序维穿梭）与 `--grade`（相位律动）使用，可精准调节分析节奏与资源消耗之间的平衡。
#### 📔 参数说明: 
- 一个可选的整数，默认值为 1（即逐帧滑动），取值范围 1 ~ 10（可根据帧率及场景灵活调整）。
- 典型设置
  - `--slide=1` 适用于高精度变化检测场景，如UI界面微动识别。
  - `--slide=5` 适用于快速预分析或轻量级变更检测。
  - `--slide=10` 适合长视频的宏观结构划分分析。
- 步长越小，帧间重叠越高，分析越精准，计算开销也越大。
- 步长越大，跳帧越明显，处理更快，但易漏检细节变化。
- 该参数适合与 `--scope`（序维穿梭）和 `--grade`（相位律动）联合调控，进一步优化精度与性能平衡。

```
`--slide=1`（精细滑动），每次向后滑动一帧，分析粒度更细，处理更耗时。

[1][2][3]
   [2][3][4]
      [3][4][5]
         [4][5][6]
            [5][6][7]
               [6][7][8]
                  [7][8][9]
                     [8][9][10]
```

```
`--slide=2`（中等滑动），滑动幅度为2帧，兼顾效率与准确率。

[1][2][3]
      [3][4][5]
            [5][6][7]
                  [7][8][9]
```

```
`--slide=3`（快速滑动），适用于快速扫描或资源受限情境。

[1][2][3]
         [4][5][6]
                  [7][8][9]
```

| 步长值范围   | 推荐值 | 应用场景         | 专业建议描述                    |
|---------|-----|--------------|---------------------------|
| `1`     | 默认  | 高精度分析、边界检测   | 逐帧对比，精度最高，适合细节定位与动态场景分析。  |
| `2 ~ 3` | 常用  | 一般场景分析、平衡效率  | 兼顾效率与精度，是大多数视频分析的推荐选项。    |
| `4 ~ 5` | 可选  | 快速预处理、资源受限分析 | 适用于大规模数据扫描，适度牺牲时序连续性换取速度。 |
| `>5`    | 不推荐 | 粗略预览、快速跳帧    | 容易丢失变化细节，仅用于低要求预览或节省计算资源。 |

| 应用场景      | `slide` 星线踏步 | `scope` 时序穿梭 | `grade` 相位律动 | 建议描述                      |
|-----------|--------------|--------------|--------------|---------------------------|
| 精细边界检测    | `1`          | `3 ~ 5`      | `1 ~ 2`      | 保留每一帧变化，适合检测动作起始、微动场景。    |
| 中速内容变化分析  | `2 ~ 3`      | `5 ~ 8`      | `2 ~ 4`      | 适配多数视频，权重逐渐增加，适合稳定动态场景。   |
| 快速滑动预处理   | `4 ~ 5`      | `8 ~ 12`     | `3 ~ 5`      | 牺牲一定精度换取速度，适合长视频粗筛或剪辑前处理。 |
| 长时段稳定监测   | `1 ~ 2`      | `10 ~ 15`    | `5 ~ 8`      | 追踪稳定画面变化趋势，如监控、慢镜头监测等。    |
| 异常高敏感识别   | `1`          | `2 ~ 3`      | `1`          | 用于突变检测、误触排查等对响应极致敏感的任务。   |
| 内容摘要/剪辑定位 | `3 ~ 4`      | `5 ~ 10`     | `3 ~ 6`      | 快速提取变化区段，适用于视频摘要、剪辑定位等场景。 |

#### 📔 应用场景:
- **高精度变化捕捉**: 检测短时UI闪烁、界面跳变、微动画错帧等。逐帧推进或低步长设置可提升变动检测灵敏度，但计算开销较大。
- **中等复杂场景切换检测**: 分析功能流转过程、页面间过渡、短时操作变化。适度减少帧间重叠，兼顾速度与局部变化感知。
- **长视频结构分析**: 用于长视频内容结构划分、段落边界粗筛、重大变化初步定位。跳帧推进能显著提高处理速度，适用于初步扫描和批量处理。
- **多视频并行对比分析**: 对比不同设备或系统版本间的执行效果。统一滑动步长有利于帧级行为对齐与同步处理。
#### 📔 实际应用: 
```
framix --slide 1
```

### ⚜️ 矩阵分割 (`--block`)
#### 📔 功能描述:
- 指定图像在水平和垂直方向上的分块数量，用于将整帧图像划分为更小的子区域。
- 提升图像处理、运动检测、局部特征提取等操作中的计算效率与空间分辨能力，适用于高分辨率视频的并行分析与局部建模。
#### 📔 参数说明: 
- 一个可选的整数，默认值为 3 (切分为 `3 x 3 = 9` 个子区域)，取值范围 1 ~ 10。
- 推荐范围 3 ~ 6，最大建议 10 更高计算开销。
- 越大则越精细，但计算成本随之增加。
- 图像尺寸应尽可能被整除，以避免边缘失真。

```
当设置 `--block=3` 时，每帧图像会被切分为 `3 x 3 = 9` 个子区域。

+------+------+------+
| blk1 | blk2 | blk3 |
+------+------+------+
| blk4 | blk5 | blk6 |
+------+------+------+
| blk7 | blk8 | blk9 |
+------+------+------+

每个块（blkX）代表一个小区域，参与局部比较（SSIM、MSE 等）。
增强对局部图像变化的检测能力。

---

当设置 `--block=1` 时，整张图像整体作为对比块。

┌──────────────────────────┐
│                          │
│                          │
│          Image           │
│                          │
│                          │
└──────────────────────────┘

图像不会被切割成多个子块，而是直接作为一整块参与后续的 SSIM、MSE、PSNR 分析。     
```

#### 📔 应用场景:
- 在进行图像特征提取、图像分析或图像预处理时，经常需要对图像的局部区域进行操作而不是整个图像。通过分块可以更容易地实现这一点。
- 在训练卷积神经网络时，有时需要从大图像中抽取多个小图像样本进行训练，以增强模型的泛化能力。
- 分块后的图像可以分布到不同的处理单元进行并行处理，从而提高处理效率。
- 通过参数 `--block`，你可以控制分割的粒度，值越大，每块的尺寸越小，总块数越多。
- 提供了很大的灵活性，可以适用于多种不同精度和性能要求的场景。
#### 📔 实际应用: 
```
framix --block 3
```

### ⚜️ 序维穿梭 (`--scope`)
#### 📔 功能描述:
- 控制滑动窗口的分析跨度，即每次运算所覆盖的帧数区间。
- 决定了算法对“时间”维度的理解深度，影响稳定性判断与细节捕捉能力。
- 本质上是时间感知的“感受器尺寸”，范围越大，感知越长；范围越小，感知越敏捷。
#### 📔 参数说明: 
- 一个可选的整数，默认值为 1（表示滑动窗口的帧数），取值范围 1 ~ 20。
- 最小值 1 （表示当前帧与下一帧对比）。
- 推荐范围 3 ~ 8（兼顾分析精度与性能）。
- 最大建议值 20（适用于冗长视频、宏观场景变化）。
- 越大越稳健，适合分析缓慢的场景变迁或全局渐变。
- 越小越灵敏，适合检测短时突变、跳剪片段或高帧率视频中的异动帧。

```
以 `--scope=3`、`--slide=1` 为例

帧序列
[ f1 ][ f2 ][ f3 ][ f4 ][ f5 ][ f6 ][ f7 ]

窗口1         f1 → f2
[ f1 ][ f2 ][ f3 ]

窗口2             f2 → f3
    [ f2 ][ f3 ][ f4 ]

窗口3                 f3 → f4
        [ f3 ][ f4 ][ f5 ]

...

每个窗口用于比较连续帧之间的变化。
可用于检测动态事件、过渡等。
```

#### 📔 应用场景:
- **转场检测**: 适合使用 `--scope=2~5` 捕捉镜头切换或场景突变。
- **稳定状态识别**: 使用 `--scope=6~10` 可提升识别鲁棒性，弱化短期噪声影响。
- **长镜头行为分析**: `--scope=12~20` 对运动缓慢、光线渐变等现象更敏感。
#### 📔 实际应用: 
```
framix --scope 1
```

### ⚜️ 相位律动 (`--grade`)
#### 📔 功能描述:
- 控制滑动窗口内各帧的加权分布方式，用于平滑值（如 SSIM、MSE、PSNR）的加权计算。
- 权重分布以幂函数方式衰减：靠近当前帧的权重更高，远离当前帧的影响力降低。
- 本质上模拟“时序惯性”与“当前性偏好”，可理解为时序分析中的“物理驱动感”。
#### 📔 参数说明: 
- 一个可选的整数，默认值为 2（表示幂函数的指数大小），取值范围 1 ~ 5。
- 最小值 1（线性加权，各帧影响均匀分布）。
- 推荐范围 2 ~ 5（平衡远近帧的权重分配）。
- 最大建议值 10（强烈强调临近帧，远帧几乎被忽略）。
- 越大越集中，权重集中于靠近窗口末端的帧。
- 越小越均衡，权重在整个窗口内更平均，适合平滑变化趋势的分析。 

```
设定 `--scope=5`、`--grade=2`，计算每帧权重

Frames   →   f1  f2  f3  f4  f5
Grade²   →   1   4   9   16  25

越靠后的帧权重越高，变化影响越大。
适用于强调“尾部”帧的瞬时变化。
```

| 应用场景 | block | scope | grade |
|------|-------|-------|-------|
| 抖动检测 | 3     | 2     | 5     |
| 渐变分析 | 4     | 6     | 3     |
| 稳态筛选 | 2     | 8     | 2     |
| 精剪识别 | 5     | 4     | 4     |

- 可根据帧率、视频变化强度、对剪辑精度的要求灵活调整。
- 如果分析结果偏少或过多，可通过调节 `--grade` 权重分布或放宽 `--scope` 范围进行微调。
#### 📔 应用场景:
- **突变响应优化**: `--grade=4~6` 有助于快速响应突然变化（如闪烁、跳剪）。
- **模式衰减建模**: `--grade=2~3` 适合处理渐变、循环变化等。
- **稳定段的过滤**: `--grade=1~2` 在判断稳定阶段时，更好兼顾远近影响。
#### 📔 实际应用: 
```
framix --grade 2
```

### ⚜️ 视界探索 (`--crops`)
#### 📔 功能描述:
- 该参数通过定义区域坐标和尺寸，允许用户灵活聚焦图像片段。
- 指定裁剪区域的左上角坐标 `(x, y)` 和该区域的宽度 `x_size` 及高度 `y_size`。
#### 📔 参数说明: 
- 格式 `x,y,x_size,y_size`（左上角坐标及区域宽高）。
- **x** 裁剪区域左上角的横向比例（0.0 ~ 1.0）。
- **y** 裁剪区域左上角的纵向比例（0.0 ~ 1.0）。
- **x_size** 裁剪区域的宽度比例。
- **y_size** 裁剪区域的高度比例。
- 所有值为浮点数，表示相对于原图尺寸的比例。
- 可使用多组 `--crops` 参数定义多个裁剪区域。

```
图像坐标系统（宽度=1.0，高度=1.0）

(0,0) ┌────────────────────────────┐
      │                            │
      │                            │
      │     ┌────────────┐         │
      │     │            │         │
      │     │ 0.25,0.25  │         │
      │     │   center   │         │
      │     └────────────┘         │
      │                            │
      └────────────────────────────┘ (1.0,1.0)

示例 `--crops 0.25,0.25,0.5,0.5` 裁剪中心区域，宽高为原图的 50%
```

#### 📔 应用场景:
- 在发布或分析视频内容时隐藏敏感信息，如个人信息、版权标识等。
- 只处理视频的某个特定区域，忽略其他部分，例如监控摄像头的特定监控区域。
#### 📔 实际应用: 
```
framix --crops 0,0,1,0.9
```
    
### ⚜️ 视界忽略 (`--omits`)
#### 📔 功能描述:
- 定义图像中应排除处理的区域。
- 与 `--crops` 相反，此参数用于标记无需参与处理或分析的图像区域。
#### 📔 参数说明: 
- 格式 `x,y,x_size,y_size`（左上角坐标及区域宽高）。
- **x** 左上角横坐标（相对比例 0.0 ~ 1.0）。
- **y** 左上角纵坐标（相对比例 0.0 ~ 1.0）。
- **x_size** 区域宽度（相对比例）。
- **y_size** 区域高度（相对比例）。
- 所有值为浮点数，表示相对于原图尺寸的比例。
- 可传入多个 `--omits` 表示排除多个区域。
```
图像宽高比例范围为 [0.0, 1.0]

(0,0) ┌────────────────────────────┐
      │████████████████████████████│ ← 忽略上方 20% 区域
      │                            │
      │                            │
      │                            │
      │                 ██████     │ ← 忽略右下角 20% 区域
      └────────────────────────────┘ (1.0,1.0)
```

#### 📔 应用场景:
- 在进行机器学习或其他分析时，忽略图像中不需要或可能干扰分析的部分，如水印、标志等。
- 为视频添加特效时，可以先屏蔽掉不需要应用特效的区域。
#### 📔 实际应用: 
```
framix --omits 0,0,1,0.2
```

---

## 🔰 漏洞追踪

### ⚜️ 架构透镜 (`--debug`)
#### 📔 功能描述: 
- 激活调试模式后，系统将进入高透明度的运行追踪状态，输出底层架构的完整执行日志。  
- 该功能专为开发和测试阶段设计，能够深入揭示每个处理阶段的内部行为和关键变量状态。
#### 📔 参数说明: 
- 一个可选的布尔值，默认为`False`。
- **开启**: 系统将记录并显示所有关键的内部操作和数据，以纯文本格式提供详细的运行时信息。
- **关闭**: 系统将只记录和显示正常操作所需的基本信息，以减少性能开销和日志产出。

```
Framix Debug Mode
     │
     ▼
[Loader]
  - 视频路径验证
  - 帧数统计
  - 尺寸提取
     │
     ▼
[Preprocess]
  - 压缩参数应用
  - 尺寸转换记录
  - 灰度钩子执行
     │
     ▼
[Analyzer]
  - 特征提取
  - SSIM/MSE 分布
  - 异常帧捕获
     │
     ▼
[Renderer]
  - 报告模板绑定
  - 缩略图绘制
  - 图表数据注入
     │
     ▼
[Output]
  - 日志路径记录
  - 报告写入状态
  - 文件保存成功标志
```

#### 📔 应用场景:
- **开发调试阶段**: 在应用开发阶段，开发者需要深入了解代码的执行过程，调试逻辑错误和性能问题。使用 `--debug` 可以捕捉详细的系统调用和变量状态，帮助开发者迅速定位问题源。
- **性能优化**: 在性能优化阶段，开发者需要了解应用在不同负载下的资源使用情况和响应时间。通过 `--debug` 模式，记录详细的性能参数和操作流程，找到性能瓶颈。
- **生产环境故障排查**: 当应用在生产环境中出现故障时，详细的运行日志对于快速定位和解决问题至关重要。开启 `--debug` 模式，系统将记录所有异常和错误的详细信息，包括上下文，便于问题的快速解决。
- **代码审查和测试**: 在代码审查和测试阶段，团队成员需要了解应用的运行状态和内部操作。使用 `--debug` 模式，记录详尽的日志信息，帮助团队成员更好地理解代码逻辑和测试结果。
- **教学和演示**: 在教学和技术演示中，详细的日志信息有助于讲解和展示应用的内部工作原理。通过 `--debug` 模式，可以清晰地展示每一步操作和系统响应，增强教学效果。
- **安全审计**: 在进行安全审计时，详细的操作日志对于检测和分析潜在的安全漏洞和异常行为非常重要。通过 `--debug` 模式，记录所有操作和数据访问，进行全面的安全分析。
#### 📔 实际应用: 
```
framix --debug
```

---

## 🖥️ 使用示例
 
### 💾 自动循环录制 (`--flick`)
```
framix --flick
```

### 💾 加速循环录制 (`--flick --speed --group`)
```
framix --flick --speed --group
```

### 💾 基础循环分析 (`--flick --basic --group`)
```
framix --flick --basic --group
```

### 💾 深度学习循环分析 (`--flick --keras --group`)
```
framix --flick --keras --group
```

### 💾 综合视频集合分析 (`--basic --group --stack`)
```
framix --basic --group --stack <视频集合路径>
```

### 💾 定制化阶段分析 (`--keras --boost --color --group --begin --final --stack`)
```
framix --keras --boost --color --group --begin 0,1 --final=-1,-1 --stack <视频集合路径>
```

### 💾 自定义分辨率调整 (`--keras --boost --color --group --shape`)
```
framix --keras --boost --color --group --shape 300,600 --video <视频文件路径>
```

### 💾 视频缩放优化 (`--keras --boost --color --group --scale`)
```
framix --keras --boost --color --group --scale 0.5 --video <视频文件路径>
```

### 💾 精确时间控制分析 (`--keras --boost --color --group --start --limit`)
```
framix --keras --boost --color --group --start 0.5 --limit 2 --video <视频文件路径>
```

### 💾 终止时间设置 (`--keras --boost --color --group --close`)
```
framix --keras --boost --color --group --close 3 --video <视频文件路径>
```

### 💾 高级分析参数配置 (`--keras --boost --color --group --frate --thres --shift --block`)
```
framix --keras --boost --color --group --frate 60 --thres 0.97 --shift 3 --block 6 --video <视频文件路径>
```

### 💾 目标区域分析 (`--keras --boost --color --group --crops`)
```
framix --keras --boost --color --group --crops 0,0.1,1,0.9 --video <视频文件路径>
```

### 💾 忽略区域设置 (`--keras --boost --color --group --omits`)
```
framix --keras --boost --color --group --omits 0,0,1,0.2 --omits 0,0.9,1,0.1 --video <视频文件路径>
```

### 💾 综合报告生成 (`--group --merge`)
```
framix --group --merge <文件夹路径> --merge <文件夹路径> --merge <文件夹路径>
```
      
### 💾 模型编译与配置 (`--build --shape`)
```
framix --shape 200,200 --build <文件夹路径> --build <文件夹路径> --build <文件夹路径>
```

---

## 🪯 核心特性

### ⭐️ 多任务处理
#### ⚔️ Framix 融合了多进程、多线程和协程技术，提供高效的视频处理能力。这些技术允许 Framix 同时分析多个视频或整个视频文件夹，大幅提升处理速度。
- **多进程**: 利用 CPU 的多核优势，同时运行多个视频分析任务。
- **多线程**: 在单个进程中同时处理多个任务，优化资源使用和响应时间。
- **协程**: 提供更轻量级的并发处理，尤其适用于 I/O 密集型操作，如文件读写。

### ⭐️ 交互式前端界面
#### ⚔️ Framix 提供多个直观且功能强大的前端界面，帮助用户更容易地管理和分析视频。
- **可视化界面**: 清晰的 UI 设计，使操作 **Framix** 更加直观和易懂。
- **交互式分析**: 通过前端界面，用户可以选择视频的开始帧和结束帧，以精确控制开始和结束部分。

### ⭐️ 多阶段报告展示
#### ⚔️ Framix 允许用户将视频分析结果划分为多个阶段，便于对特定部分进行详细审查。
- **分阶段展示**: 用户可以将视频帧分解成多个阶段，如启动阶段、交互阶段等，每个阶段的分析结果单独展示。
- **自定义阶段**: 根据需要，用户可自定义分阶段的标准和数量。

### ⭐️ 重点帧展示
#### ⚔️ Framix 提供突出显示视频中重要帧的功能。
- **重点帧识别**: 自动识别并突出显示视频中的关键帧，如性能峰值或异常帧。
- **重点帧导航**: 用户可以快速导航至这些重要帧，便于详细分析。

### ⭐️ 综合报告汇总
#### ⚔️ Framix 支持将多个视频的分析结果汇总到一个综合报告中。
- **整体视角**: 提供全局视角，将多个视频的分析结果聚合展示。
- **对比分析**: 便于对比不同视频间的性能表现差异。

### ⭐️ 自动帧差计算
#### ⚔️ Framix 能自动计算并展示视频帧之间的差异。
- **帧差展示**: 在报告中展示连续帧之间的变化，帮助识别性能波动点。
- **动态调整**: 用户可以根据需要调整帧差计算的精度和范围。

### ⭐️ 一键复制功能
#### ⚔️ Framix 提供一键复制帧差结果的功能，便于将数据导出或分享。
- **快捷操作**: 提高操作效率，尤其在需要将结果快速整合到其他文档或报告中时。

### ⭐️ 性能优化
#### ⚔️ Framix 的设计注重性能和速度，即使处理大量视频数据也能保持流畅。
- **前端优化**: 前端页面的展示效果优化，确保用户在分析和浏览结果时获得流畅的体验。

---

## ⚛️ 新的纪元

### 💎 时代变革
- **Framix** 的诞生，让我们正见证着性能测试领域的一场划时代变革。这不仅仅是工具本身的飞跃，更是对开发和测试流程的深刻革命。
- 在快速发展、持续变化的技术世界中，**Framix** 代表着更高效、更全面解决方案的典范，使得性能测试不再是开发生命周期中的瓶颈，而是成为了加速产品迭代和优化的强大推动力。

### 💎 核心价值
- **Framix** 的核心价值在于其创新性和灵活性。它不仅能够适应多变的测试环境，更能够提供直观、精确的分析，让性能瓶颈无处遁形。
- 它的应用将极大地提升软件的可靠性和用户体验，使得性能测试成为一项令人兴奋和值得投资的领域。

### 💎 全新时代 
- 更为重要的是，**Framix** 引领了一个全新的时代，它将激励我们不断探索未知，勇于突破传统的束缚。
- 在这个数字化快速演变的时代，**Framix** 不仅为开发者和测试工程师提供了一把钥匙，还为整个行业描绘了一幅未来技术进步的宏伟蓝图。它不仅仅是工具，更是一场思维和方法论的革命。

### 💎 广阔未来 
- 当我们站在这个技术革新的前沿，**Framix** 提醒我们: 创新是无止境的探索之旅。我们今天所见证的，可能只是更广阔未来的起点。
- 让我们期待更多创新的诞生，共同推动这个令人激动的技术革新旅程，探索无限可能。

---

## Framix｜画帧秀 编译 / Compile

![LOGO](schematic/resources/images/illustration/Compile.png)

---

### 前提条件
#### 在开始之前，请确保已完成以下操作:
- 安装 **[Python](https://www.python.org/downloads/) 3.11** 或更高版本
- 安装 **[Nuitka](https://nuitka.net/)**
  - 导航到您的 **Python** 脚本所在的目录
    ```
    pip install nuitka==2.7
    ```

- 确保在项目根目录下有一个 `requirements.txt` 文件，其中列出了所有的依赖包
> **NexaFlow**
>> **requirements.txt**

- 确保您的 **Python** 环境中安装了所有依赖包
  - **海外** 导航到您的 **Python** 脚本所在的目录
    ```
    pip install -r requirements.txt
    ```
  - **大陆** 导航到您的 **Python** 脚本所在的目录
    ```
    pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple
    ```

- 在 **Python** 脚本所在的目录新建 `applications` 目录
> **NexaFlow**
>> **applications**

---

### 工具目录

#### 新建 `supports` 目录以及子目录，拷贝可执行文件至对应目录
- schematic
  - resources
  - supports
    - MacOS
      - ffmpeg
        - bin
          - ffmpeg
          - ffprobe
      - platform-tools
        - ...
        - adb
        - ...
    - Windows
      - ffmpeg
        - bin
          - ffmpeg.exe
          - ffprobe.exe
        - ...
      - platform-tools
        - adb.exe
        - ...
  - templates
    - ...

---

### Windows 操作系统
#### 准备工作
- 打开命令提示符 **Command Prompt** 或 **PowerShell**
- 导航到您的 **Python** 脚本所在的目录

#### 运行根目录下 `build.py` 文件
> **NexaFlow**
>> **build.py**

#### 目录结构
- **applications**
  - **FramixEngine**
    - **schematic**
    - **...**
  - **framix.bat**
  - **Structure**
    - **Framix_Mix**
    - **Framix_Model**
      - **Keras_Gray_W256_H256**
      - **Keras_Hued_W256_H256**
    - **Framix_Report**

---

### MacOS 操作系统
#### 准备工作
- 打开终端 **Terminal** 
- 导航到您的 **Python** 脚本所在的目录

#### 运行根目录下 `build.py` 文件
> **NexaFlow**
>> **build.py**

#### 目录结构
- **applications**
  - **Framix.app**
    - **Contents**
      - **_CodeSignature**
      - **MacOS**
        - **schematic**
        - **framix.sh**
        - **framix**
        - **...**
      - **Resources**
        - **framix_macos_bg.png**
        - ...
      - **Structure**
        - **Framix_Mix**
        - **Framix_Model**
          - **Keras_Gray_W256_H256**
          - **Keras_Hued_W256_H256**
        - **Framix_Report**
      - **Info.plist**

---

## 🖐️ 技术支持
### ⭐️ 遇到任何问题，欢迎联系我们的技术支持团队。我们随时准备协助您解决问题。
- **[Welcome to issues!](https://github.com/PlaxtonFlarion/NexaFlow/issues)**

---

## 👥 社区协作
### ⭐️ 加入我们的行列！
- 无论是通过 **[Pull Request](https://github.com/PlaxtonFlarion/NexaFlow/pulls)** 还是 **[Issue](https://github.com/PlaxtonFlarion/NexaFlow/issues)**，您的智慧都是我们的财富。

---

## 📜 开源协议
### ⭐️ 我们遵循所有内置工具的开源许可和版权政策，并在应用中包含了原始许可证文本。
- **Framix** 采用 **[MIT](LICENSE.md)** 许可，与世界共享创新成果。

---

## 📬 互动交流
### ⭐️ 有疑问？有灵感？我们期待您的来信: 
- **[AceKeppel@outlook.com]**
- **Framix** - 让性能测试变得简单、高效而智能。

---
